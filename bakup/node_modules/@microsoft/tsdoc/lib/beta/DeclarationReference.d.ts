/**
 * Represents a reference to a declaration.
 * @beta
 */
export declare class DeclarationReference {
    private _source;
    private _navigation;
    private _symbol;
    constructor(source?: ModuleSource | GlobalSource, navigation?: Navigation.Locals | Navigation.Exports, symbol?: SymbolReference);
    readonly source: ModuleSource | GlobalSource | undefined;
    readonly navigation: Navigation.Locals | Navigation.Exports | undefined;
    readonly symbol: SymbolReference | undefined;
    readonly isEmpty: boolean;
    static parse(text: string): DeclarationReference;
    static makeSafeComponent(text: string): string;
    static empty(): DeclarationReference;
    static module(path: string): DeclarationReference;
    static global(): DeclarationReference;
    withSource(source: ModuleSource | GlobalSource | undefined): DeclarationReference;
    withNavigation(navigation: Navigation.Locals | Navigation.Exports | undefined): DeclarationReference;
    withSymbol(symbol: SymbolReference | undefined): DeclarationReference;
    withComponent(component: Component): DeclarationReference;
    withMeaning(meaning: Meaning | undefined): DeclarationReference;
    withOverloadIndex(overloadIndex: number | undefined): DeclarationReference;
    addNavigationStep(navigation: Navigation, text: string): DeclarationReference;
    toString(): string;
}
/**
 * Indicates the symbol table from which to resolve the next symbol component.
 * @beta
 */
export declare const enum Navigation {
    Exports = ".",
    Members = "#",
    Locals = "~"
}
/**
 * Represents a module.
 * @beta
 */
export declare class ModuleSource {
    readonly path: string;
    constructor(path: string, escapeIfNeeded?: boolean);
    toString(): string;
}
/**
 * Represents the global scope.
 * @beta
 */
export declare class GlobalSource {
    static readonly instance: GlobalSource;
    private constructor();
    toString(): string;
}
/**
 * @beta
 */
export declare type Component = RootComponent | NavigationComponent;
/**
 * @beta
 */
export declare abstract class ComponentBase {
    readonly text: string;
    constructor(text: string, escapeIfNeeded?: boolean);
    addNavigationStep(this: Component, navigation: Navigation, text: string): Component;
    abstract toString(): string;
}
/**
 * @beta
 */
export declare class RootComponent extends ComponentBase {
    toString(): string;
}
/**
 * @beta
 */
export declare class NavigationComponent extends ComponentBase {
    readonly parent: Component;
    readonly navigation: Navigation;
    constructor(source: Component, navigation: Navigation, text: string, escapeIfNeeded?: boolean);
    toString(): string;
}
/**
 * @beta
 */
export declare const enum Meaning {
    Class = "class",
    Interface = "interface",
    TypeAlias = "typealias",
    Enum = "enum",
    Namespace = "namespace",
    Function = "function",
    Variable = "variable",
    Constructor = "constructor",
    Member = "member",
    Event = "event",
    EnumMember = "enummember",
    Signature = "signature",
    Type = "type"
}
/**
 * @beta
 */
export interface ISymbolReferenceOptions {
    meaning?: Meaning;
    overloadIndex?: number;
}
/**
 * Represents a reference to a TypeScript symbol.
 * @beta
 */
export declare class SymbolReference {
    readonly component: Component;
    readonly meaning: Meaning | undefined;
    readonly overloadIndex: number | undefined;
    constructor(component: Component, { meaning, overloadIndex }?: ISymbolReferenceOptions);
    withComponent(component: Component): SymbolReference;
    withMeaning(meaning: Meaning | undefined): SymbolReference;
    withOverloadIndex(overloadIndex: number | undefined): SymbolReference;
    addNavigationStep(navigation: Navigation, text: string): SymbolReference;
    toString(): string;
}
