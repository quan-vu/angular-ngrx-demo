(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "typescript", "./ast_tools"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const ts = require("typescript");
    const ast_tools_1 = require("./ast_tools");
    /**
     * Determines if the given ts.Node is literal enough for security purposes.
     */
    function isLiteral(typeChecker, node) {
        if (ts.isBinaryExpression(node) &&
            node.operatorToken.kind === ts.SyntaxKind.PlusToken) {
            // Concatenation is fine, if the parts are literals.
            return (isLiteral(typeChecker, node.left) &&
                isLiteral(typeChecker, node.right));
        }
        else if (ts.isTemplateExpression(node)) {
            // Same for template expressions.
            return node.templateSpans.every(span => {
                return isLiteral(typeChecker, span.expression);
            });
        }
        else if (ts.isTemplateLiteral(node)) {
            // and literals (in that order).
            return true;
        }
        else if (ts.isConditionalExpression(node)) {
            return isLiteral(typeChecker, node.whenTrue) &&
                isLiteral(typeChecker, node.whenFalse);
        }
        else if (ts.isIdentifier(node)) {
            return isUnderlyingValueAStringLiteral(node, typeChecker);
        }
        const hasCasts = ast_tools_1.findInChildren(node, ts.isAsExpression);
        return !hasCasts && isLiteralAccordingToItsType(typeChecker, node);
    }
    exports.isLiteral = isLiteral;
    /**
     * Given an identifier, this function goes around the AST to determine
     * whether we should consider it a string literal, on a best-effort basis. It
     * is an approximation, but should never have false positives.
     */
    function isUnderlyingValueAStringLiteral(identifier, tc) {
        // The identifier references a value, and we try to follow the trail: if we
        // find a variable declaration for the identifier, and it was declared as a
        // const (so we know it wasn't altered along the way), then the value used
        // in the declaration is the value our identifier references. That means we
        // should look at the value used in its initialization (by applying the same
        // rules as before).
        // Since we're best-effort, if a part of that operation failed due to lack
        // of support (for instance, the identifier was imported), then we fail
        // closed and don't consider the value a literal.
        // TODO(rjamet): This doesn't follow imports, which is a feature that we need
        // in a fair amount of cases.
        return getVariableDeclarationsInSameFile(identifier, tc)
            .filter(isConst)
            .some(d => d.initializer !== undefined && isLiteral(tc, d.initializer));
    }
    /**
     * Returns whether this thing is a literal based on TS's understanding. This is
     * only looking at the local type, so there's no magic in that function.
     */
    function isLiteralAccordingToItsType(typeChecker, node) {
        const nodeType = typeChecker.getTypeAtLocation(node);
        return (nodeType.flags &
            (ts.TypeFlags.StringLiteral | ts.TypeFlags.NumberLiteral |
                ts.TypeFlags.BooleanLiteral | ts.TypeFlags.EnumLiteral)) !== 0;
    }
    /**
     * Follows the symbol behind the given identifier, assuming it is a variable,
     * and return all the variable declarations we can find that match it in the
     * same file.
     */
    function getVariableDeclarationsInSameFile(node, tc) {
        const symbol = tc.getSymbolAtLocation(node);
        if (!symbol) {
            return [];
        }
        const decls = symbol.getDeclarations();
        if (!decls) {
            return [];
        }
        return decls.filter(ts.isVariableDeclaration);
    }
    // Tests whether the given variable declaration is Const.
    function isConst(varDecl) {
        return Boolean(varDecl && varDecl.parent &&
            ts.isVariableDeclarationList(varDecl.parent) &&
            varDecl.parent.flags & ts.NodeFlags.Const);
    }
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaXNfbGl0ZXJhbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL2V4dGVybmFsL2J1aWxkX2JhemVsX3J1bGVzX3R5cGVzY3JpcHQvaW50ZXJuYWwvdHNldHNlL3V0aWwvaXNfbGl0ZXJhbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztJQUFBLGlDQUFpQztJQUNqQywyQ0FBMkM7SUFFM0M7O09BRUc7SUFDSCxTQUFnQixTQUFTLENBQUMsV0FBMkIsRUFBRSxJQUFhO1FBQ2xFLElBQUksRUFBRSxDQUFDLGtCQUFrQixDQUFDLElBQUksQ0FBQztZQUMzQixJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksS0FBSyxFQUFFLENBQUMsVUFBVSxDQUFDLFNBQVMsRUFBRTtZQUN2RCxvREFBb0Q7WUFDcEQsT0FBTyxDQUNILFNBQVMsQ0FBQyxXQUFXLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQztnQkFDakMsU0FBUyxDQUFDLFdBQVcsRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztTQUN6QzthQUFNLElBQUksRUFBRSxDQUFDLG9CQUFvQixDQUFDLElBQUksQ0FBQyxFQUFFO1lBQ3hDLGlDQUFpQztZQUNqQyxPQUFPLElBQUksQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFO2dCQUNyQyxPQUFPLFNBQVMsQ0FBQyxXQUFXLEVBQUUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1lBQ2pELENBQUMsQ0FBQyxDQUFDO1NBQ0o7YUFBTSxJQUFJLEVBQUUsQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUNyQyxnQ0FBZ0M7WUFDaEMsT0FBTyxJQUFJLENBQUM7U0FDYjthQUFNLElBQUksRUFBRSxDQUFDLHVCQUF1QixDQUFDLElBQUksQ0FBQyxFQUFFO1lBQzNDLE9BQU8sU0FBUyxDQUFDLFdBQVcsRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDO2dCQUN4QyxTQUFTLENBQUMsV0FBVyxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztTQUM1QzthQUFNLElBQUksRUFBRSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUNoQyxPQUFPLCtCQUErQixDQUFDLElBQUksRUFBRSxXQUFXLENBQUMsQ0FBQztTQUMzRDtRQUVELE1BQU0sUUFBUSxHQUFHLDBCQUFjLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxjQUFjLENBQUMsQ0FBQztRQUV6RCxPQUFPLENBQUMsUUFBUSxJQUFJLDJCQUEyQixDQUFDLFdBQVcsRUFBRSxJQUFJLENBQUMsQ0FBQztJQUNyRSxDQUFDO0lBekJELDhCQXlCQztJQUVEOzs7O09BSUc7SUFDSCxTQUFTLCtCQUErQixDQUNwQyxVQUF5QixFQUFFLEVBQWtCO1FBQy9DLDJFQUEyRTtRQUMzRSwyRUFBMkU7UUFDM0UsMEVBQTBFO1FBQzFFLDJFQUEyRTtRQUMzRSw0RUFBNEU7UUFDNUUsb0JBQW9CO1FBQ3BCLDBFQUEwRTtRQUMxRSx1RUFBdUU7UUFDdkUsaURBQWlEO1FBRWpELDZFQUE2RTtRQUM3RSw2QkFBNkI7UUFDN0IsT0FBTyxpQ0FBaUMsQ0FBQyxVQUFVLEVBQUUsRUFBRSxDQUFDO2FBQ25ELE1BQU0sQ0FBQyxPQUFPLENBQUM7YUFDZixJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsV0FBVyxLQUFLLFNBQVMsSUFBSSxTQUFTLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDO0lBQzlFLENBQUM7SUFFRDs7O09BR0c7SUFDSCxTQUFTLDJCQUEyQixDQUNoQyxXQUEyQixFQUFFLElBQWE7UUFDNUMsTUFBTSxRQUFRLEdBQUcsV0FBVyxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3JELE9BQU8sQ0FBQyxRQUFRLENBQUMsS0FBSztZQUNkLENBQUMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxhQUFhLEdBQUcsRUFBRSxDQUFDLFNBQVMsQ0FBQyxhQUFhO2dCQUN2RCxFQUFFLENBQUMsU0FBUyxDQUFDLGNBQWMsR0FBRyxFQUFFLENBQUMsU0FBUyxDQUFDLFdBQVcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQzFFLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsU0FBUyxpQ0FBaUMsQ0FDdEMsSUFBbUIsRUFBRSxFQUFrQjtRQUN6QyxNQUFNLE1BQU0sR0FBRyxFQUFFLENBQUMsbUJBQW1CLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDNUMsSUFBSSxDQUFDLE1BQU0sRUFBRTtZQUNYLE9BQU8sRUFBRSxDQUFDO1NBQ1g7UUFDRCxNQUFNLEtBQUssR0FBRyxNQUFNLENBQUMsZUFBZSxFQUFFLENBQUM7UUFDdkMsSUFBSSxDQUFDLEtBQUssRUFBRTtZQUNWLE9BQU8sRUFBRSxDQUFDO1NBQ1g7UUFDRCxPQUFPLEtBQUssQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLHFCQUFxQixDQUFDLENBQUM7SUFDaEQsQ0FBQztJQUVELHlEQUF5RDtJQUN6RCxTQUFTLE9BQU8sQ0FBQyxPQUErQjtRQUM5QyxPQUFPLE9BQU8sQ0FDVixPQUFPLElBQUksT0FBTyxDQUFDLE1BQU07WUFDekIsRUFBRSxDQUFDLHlCQUF5QixDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUM7WUFDNUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxLQUFLLEdBQUcsRUFBRSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNqRCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgdHMgZnJvbSAndHlwZXNjcmlwdCc7XG5pbXBvcnQge2ZpbmRJbkNoaWxkcmVufSBmcm9tICcuL2FzdF90b29scyc7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgZ2l2ZW4gdHMuTm9kZSBpcyBsaXRlcmFsIGVub3VnaCBmb3Igc2VjdXJpdHkgcHVycG9zZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0xpdGVyYWwodHlwZUNoZWNrZXI6IHRzLlR5cGVDaGVja2VyLCBub2RlOiB0cy5Ob2RlKTogYm9vbGVhbiB7XG4gIGlmICh0cy5pc0JpbmFyeUV4cHJlc3Npb24obm9kZSkgJiZcbiAgICAgIG5vZGUub3BlcmF0b3JUb2tlbi5raW5kID09PSB0cy5TeW50YXhLaW5kLlBsdXNUb2tlbikge1xuICAgIC8vIENvbmNhdGVuYXRpb24gaXMgZmluZSwgaWYgdGhlIHBhcnRzIGFyZSBsaXRlcmFscy5cbiAgICByZXR1cm4gKFxuICAgICAgICBpc0xpdGVyYWwodHlwZUNoZWNrZXIsIG5vZGUubGVmdCkgJiZcbiAgICAgICAgaXNMaXRlcmFsKHR5cGVDaGVja2VyLCBub2RlLnJpZ2h0KSk7XG4gIH0gZWxzZSBpZiAodHMuaXNUZW1wbGF0ZUV4cHJlc3Npb24obm9kZSkpIHtcbiAgICAvLyBTYW1lIGZvciB0ZW1wbGF0ZSBleHByZXNzaW9ucy5cbiAgICByZXR1cm4gbm9kZS50ZW1wbGF0ZVNwYW5zLmV2ZXJ5KHNwYW4gPT4ge1xuICAgICAgcmV0dXJuIGlzTGl0ZXJhbCh0eXBlQ2hlY2tlciwgc3Bhbi5leHByZXNzaW9uKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmICh0cy5pc1RlbXBsYXRlTGl0ZXJhbChub2RlKSkge1xuICAgIC8vIGFuZCBsaXRlcmFscyAoaW4gdGhhdCBvcmRlcikuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAodHMuaXNDb25kaXRpb25hbEV4cHJlc3Npb24obm9kZSkpIHtcbiAgICByZXR1cm4gaXNMaXRlcmFsKHR5cGVDaGVja2VyLCBub2RlLndoZW5UcnVlKSAmJlxuICAgICAgICBpc0xpdGVyYWwodHlwZUNoZWNrZXIsIG5vZGUud2hlbkZhbHNlKTtcbiAgfSBlbHNlIGlmICh0cy5pc0lkZW50aWZpZXIobm9kZSkpIHtcbiAgICByZXR1cm4gaXNVbmRlcmx5aW5nVmFsdWVBU3RyaW5nTGl0ZXJhbChub2RlLCB0eXBlQ2hlY2tlcik7XG4gIH1cblxuICBjb25zdCBoYXNDYXN0cyA9IGZpbmRJbkNoaWxkcmVuKG5vZGUsIHRzLmlzQXNFeHByZXNzaW9uKTtcblxuICByZXR1cm4gIWhhc0Nhc3RzICYmIGlzTGl0ZXJhbEFjY29yZGluZ1RvSXRzVHlwZSh0eXBlQ2hlY2tlciwgbm9kZSk7XG59XG5cbi8qKlxuICogR2l2ZW4gYW4gaWRlbnRpZmllciwgdGhpcyBmdW5jdGlvbiBnb2VzIGFyb3VuZCB0aGUgQVNUIHRvIGRldGVybWluZVxuICogd2hldGhlciB3ZSBzaG91bGQgY29uc2lkZXIgaXQgYSBzdHJpbmcgbGl0ZXJhbCwgb24gYSBiZXN0LWVmZm9ydCBiYXNpcy4gSXRcbiAqIGlzIGFuIGFwcHJveGltYXRpb24sIGJ1dCBzaG91bGQgbmV2ZXIgaGF2ZSBmYWxzZSBwb3NpdGl2ZXMuXG4gKi9cbmZ1bmN0aW9uIGlzVW5kZXJseWluZ1ZhbHVlQVN0cmluZ0xpdGVyYWwoXG4gICAgaWRlbnRpZmllcjogdHMuSWRlbnRpZmllciwgdGM6IHRzLlR5cGVDaGVja2VyKSB7XG4gIC8vIFRoZSBpZGVudGlmaWVyIHJlZmVyZW5jZXMgYSB2YWx1ZSwgYW5kIHdlIHRyeSB0byBmb2xsb3cgdGhlIHRyYWlsOiBpZiB3ZVxuICAvLyBmaW5kIGEgdmFyaWFibGUgZGVjbGFyYXRpb24gZm9yIHRoZSBpZGVudGlmaWVyLCBhbmQgaXQgd2FzIGRlY2xhcmVkIGFzIGFcbiAgLy8gY29uc3QgKHNvIHdlIGtub3cgaXQgd2Fzbid0IGFsdGVyZWQgYWxvbmcgdGhlIHdheSksIHRoZW4gdGhlIHZhbHVlIHVzZWRcbiAgLy8gaW4gdGhlIGRlY2xhcmF0aW9uIGlzIHRoZSB2YWx1ZSBvdXIgaWRlbnRpZmllciByZWZlcmVuY2VzLiBUaGF0IG1lYW5zIHdlXG4gIC8vIHNob3VsZCBsb29rIGF0IHRoZSB2YWx1ZSB1c2VkIGluIGl0cyBpbml0aWFsaXphdGlvbiAoYnkgYXBwbHlpbmcgdGhlIHNhbWVcbiAgLy8gcnVsZXMgYXMgYmVmb3JlKS5cbiAgLy8gU2luY2Ugd2UncmUgYmVzdC1lZmZvcnQsIGlmIGEgcGFydCBvZiB0aGF0IG9wZXJhdGlvbiBmYWlsZWQgZHVlIHRvIGxhY2tcbiAgLy8gb2Ygc3VwcG9ydCAoZm9yIGluc3RhbmNlLCB0aGUgaWRlbnRpZmllciB3YXMgaW1wb3J0ZWQpLCB0aGVuIHdlIGZhaWxcbiAgLy8gY2xvc2VkIGFuZCBkb24ndCBjb25zaWRlciB0aGUgdmFsdWUgYSBsaXRlcmFsLlxuXG4gIC8vIFRPRE8ocmphbWV0KTogVGhpcyBkb2Vzbid0IGZvbGxvdyBpbXBvcnRzLCB3aGljaCBpcyBhIGZlYXR1cmUgdGhhdCB3ZSBuZWVkXG4gIC8vIGluIGEgZmFpciBhbW91bnQgb2YgY2FzZXMuXG4gIHJldHVybiBnZXRWYXJpYWJsZURlY2xhcmF0aW9uc0luU2FtZUZpbGUoaWRlbnRpZmllciwgdGMpXG4gICAgICAuZmlsdGVyKGlzQ29uc3QpXG4gICAgICAuc29tZShkID0+IGQuaW5pdGlhbGl6ZXIgIT09IHVuZGVmaW5lZCAmJiBpc0xpdGVyYWwodGMsIGQuaW5pdGlhbGl6ZXIpKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyB0aGluZyBpcyBhIGxpdGVyYWwgYmFzZWQgb24gVFMncyB1bmRlcnN0YW5kaW5nLiBUaGlzIGlzXG4gKiBvbmx5IGxvb2tpbmcgYXQgdGhlIGxvY2FsIHR5cGUsIHNvIHRoZXJlJ3Mgbm8gbWFnaWMgaW4gdGhhdCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gaXNMaXRlcmFsQWNjb3JkaW5nVG9JdHNUeXBlKFxuICAgIHR5cGVDaGVja2VyOiB0cy5UeXBlQ2hlY2tlciwgbm9kZTogdHMuTm9kZSk6IGJvb2xlYW4ge1xuICBjb25zdCBub2RlVHlwZSA9IHR5cGVDaGVja2VyLmdldFR5cGVBdExvY2F0aW9uKG5vZGUpO1xuICByZXR1cm4gKG5vZGVUeXBlLmZsYWdzICZcbiAgICAgICAgICAodHMuVHlwZUZsYWdzLlN0cmluZ0xpdGVyYWwgfCB0cy5UeXBlRmxhZ3MuTnVtYmVyTGl0ZXJhbCB8XG4gICAgICAgICAgIHRzLlR5cGVGbGFncy5Cb29sZWFuTGl0ZXJhbCB8IHRzLlR5cGVGbGFncy5FbnVtTGl0ZXJhbCkpICE9PSAwO1xufVxuXG4vKipcbiAqIEZvbGxvd3MgdGhlIHN5bWJvbCBiZWhpbmQgdGhlIGdpdmVuIGlkZW50aWZpZXIsIGFzc3VtaW5nIGl0IGlzIGEgdmFyaWFibGUsXG4gKiBhbmQgcmV0dXJuIGFsbCB0aGUgdmFyaWFibGUgZGVjbGFyYXRpb25zIHdlIGNhbiBmaW5kIHRoYXQgbWF0Y2ggaXQgaW4gdGhlXG4gKiBzYW1lIGZpbGUuXG4gKi9cbmZ1bmN0aW9uIGdldFZhcmlhYmxlRGVjbGFyYXRpb25zSW5TYW1lRmlsZShcbiAgICBub2RlOiB0cy5JZGVudGlmaWVyLCB0YzogdHMuVHlwZUNoZWNrZXIpOiB0cy5WYXJpYWJsZURlY2xhcmF0aW9uW10ge1xuICBjb25zdCBzeW1ib2wgPSB0Yy5nZXRTeW1ib2xBdExvY2F0aW9uKG5vZGUpO1xuICBpZiAoIXN5bWJvbCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBjb25zdCBkZWNscyA9IHN5bWJvbC5nZXREZWNsYXJhdGlvbnMoKTtcbiAgaWYgKCFkZWNscykge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICByZXR1cm4gZGVjbHMuZmlsdGVyKHRzLmlzVmFyaWFibGVEZWNsYXJhdGlvbik7XG59XG5cbi8vIFRlc3RzIHdoZXRoZXIgdGhlIGdpdmVuIHZhcmlhYmxlIGRlY2xhcmF0aW9uIGlzIENvbnN0LlxuZnVuY3Rpb24gaXNDb25zdCh2YXJEZWNsOiB0cy5WYXJpYWJsZURlY2xhcmF0aW9uKTogYm9vbGVhbiB7XG4gIHJldHVybiBCb29sZWFuKFxuICAgICAgdmFyRGVjbCAmJiB2YXJEZWNsLnBhcmVudCAmJlxuICAgICAgdHMuaXNWYXJpYWJsZURlY2xhcmF0aW9uTGlzdCh2YXJEZWNsLnBhcmVudCkgJiZcbiAgICAgIHZhckRlY2wucGFyZW50LmZsYWdzICYgdHMuTm9kZUZsYWdzLkNvbnN0KTtcbn1cbiJdfQ==