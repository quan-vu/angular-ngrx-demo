(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "typescript", "./ast_tools"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const ts = require("typescript");
    const ast_tools_1 = require("./ast_tools");
    /**
     * A simple Fixer builder based on a function that looks at a node, and
     * output either nothing, or a replacement. If this is too limiting, implement
     * Fixer instead.
     */
    function buildReplacementFixer(potentialReplacementGenerator) {
        return {
            getFixForFlaggedNode: (n, v) => {
                const partialFix = potentialReplacementGenerator(n, v);
                if (!partialFix) {
                    return;
                }
                return {
                    changes: [{
                            sourceFile: n.getSourceFile(),
                            start: n.getStart(),
                            end: n.getEnd(),
                            replacement: partialFix.replaceWith,
                        }],
                };
            }
        };
    }
    exports.buildReplacementFixer = buildReplacementFixer;
    // TODO(rjamet): Both maybeAddNamedImport and maybeAddNamespacedImport are too
    // hard to read to my taste. This could probably be improved upon by being more
    // functionnal, to show the filter passes and get rid of the continues and
    // returns (which are confusing).
    /**
     * Builds an IndividualChange that imports the required symbol from the given
     * file under the given name. This might reimport the same thing twice in some
     * cases, but it will always make it available under the right name (though
     * its name might collide with other imports, as we don't currently check for
     * that).
     */
    function maybeAddNamedImport(source, importWhat, fromFile, importAs, tazeComment, v) {
        const importStatements = source.statements.filter(ts.isImportDeclaration);
        const importSpecifier = importAs ? `${importWhat} as ${importAs}` : importWhat;
        for (const iDecl of importStatements) {
            const parsedDecl = maybeParseImportNode(iDecl, v);
            if (!parsedDecl || parsedDecl.fromFile !== fromFile) {
                // Not an import from the right file, or couldn't understand the import.
                continue; // Jump to the next import.
            }
            if (ts.isNamespaceImport(parsedDecl.namedBindings)) {
                ast_tools_1.debugLog(v, `... but it's a wildcard import`);
                continue; // Jump to the next import.
            }
            // Else, bindings is a NamedImports. We can now search whether the right
            // symbol is there under the right name.
            const foundRightImport = parsedDecl.namedBindings.elements.some(iSpec => iSpec.propertyName ?
                iSpec.name.getText() === importAs && // import {foo as bar}
                    iSpec.propertyName.getText() === importWhat :
                iSpec.name.getText() === importWhat); // import {foo}
            if (foundRightImport) {
                ast_tools_1.debugLog(v, `"${iDecl.getFullText()}" imports ${importWhat} as we want.`);
                return; // Our request is already imported under the right name.
            }
            // Else, insert our symbol in the list of imports from that file.
            ast_tools_1.debugLog(v, `No named imports from that file, generating new fix`);
            return {
                start: parsedDecl.namedBindings.elements[0].getStart(),
                end: parsedDecl.namedBindings.elements[0].getStart(),
                sourceFile: source,
                replacement: `${importSpecifier}, `,
            };
        }
        // If we get here, we didn't find anything imported from the wanted file, so
        // we'll need the full import string. Add it after the last import,
        // and let clang-format handle the rest.
        const newImportStatement = `import {${importSpecifier}} from '${fromFile}';` +
            (tazeComment ? `  ${tazeComment}\n` : `\n`);
        const insertionPosition = importStatements.length ?
            importStatements[importStatements.length - 1].getEnd() + 1 :
            0;
        return {
            start: insertionPosition,
            end: insertionPosition,
            sourceFile: source,
            replacement: newImportStatement,
        };
    }
    exports.maybeAddNamedImport = maybeAddNamedImport;
    /**
     * Builds an IndividualChange that imports the required namespace from the given
     * file under the given name. This might reimport the same thing twice in some
     * cases, but it will always make it available under the right name (though
     * its name might collide with other imports, as we don't currently check for
     * that).
     */
    function maybeAddNamespaceImport(source, fromFile, importAs, tazeComment, v) {
        const importStatements = source.statements.filter(ts.isImportDeclaration);
        const hasTheRightImport = importStatements.some(iDecl => {
            const parsedDecl = maybeParseImportNode(iDecl, v);
            if (!parsedDecl || parsedDecl.fromFile !== fromFile) {
                // Not an import from the right file, or couldn't understand the import.
                return false;
            }
            ast_tools_1.debugLog(v, `"${iDecl.getFullText()}" is an import from the right file`);
            if (ts.isNamedImports(parsedDecl.namedBindings)) {
                ast_tools_1.debugLog(v, `... but it's a named import`);
                return false; // irrelevant to our namespace imports
            }
            // Else, bindings is a NamespaceImport.
            if (parsedDecl.namedBindings.name.getText() !== importAs) {
                ast_tools_1.debugLog(v, `... but not the right name, we need to reimport`);
                return false;
            }
            ast_tools_1.debugLog(v, `... and the right name, no need to reimport`);
            return true;
        });
        if (!hasTheRightImport) {
            const insertionPosition = importStatements.length ?
                importStatements[importStatements.length - 1].getEnd() + 1 :
                0;
            return {
                start: insertionPosition,
                end: insertionPosition,
                sourceFile: source,
                replacement: tazeComment ?
                    `import * as ${importAs} from '${fromFile}';  ${tazeComment}\n` :
                    `import * as ${importAs} from '${fromFile}';\n`,
            };
        }
        return;
    }
    exports.maybeAddNamespaceImport = maybeAddNamespaceImport;
    /**
     * This tries to make sense of an ImportDeclaration, and returns the interesting
     * parts, undefined if the import declaration is valid but not understandable by
     * the checker.
     */
    function maybeParseImportNode(iDecl, v) {
        if (!iDecl.importClause) {
            // something like import "./file";
            ast_tools_1.debugLog(v, `Ignoring import without imported symbol: ${iDecl.getFullText()}`);
            return;
        }
        if (iDecl.importClause.name || !iDecl.importClause.namedBindings) {
            // Seems to happen in defaults imports like import Foo from 'Bar'.
            // Not much we can do with that when trying to get a hold of some symbols,
            // so just ignore that line (worst case, we'll suggest another import
            // style).
            ast_tools_1.debugLog(v, `Ignoring import: ${iDecl.getFullText()}`);
            return;
        }
        if (!ts.isStringLiteral(iDecl.moduleSpecifier)) {
            ast_tools_1.debugLog(v, `Ignoring import whose module specifier is not literal`);
            return;
        }
        return {
            namedBindings: iDecl.importClause.namedBindings,
            fromFile: iDecl.moduleSpecifier.text
        };
    }
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZml4ZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9leHRlcm5hbC9idWlsZF9iYXplbF9ydWxlc190eXBlc2NyaXB0L2ludGVybmFsL3RzZXRzZS91dGlsL2ZpeGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0lBQUEsaUNBQWlDO0lBRWpDLDJDQUFxQztJQVlyQzs7OztPQUlHO0lBQ0gsU0FBZ0IscUJBQXFCLENBQ2pDLDZCQUN1QztRQUN6QyxPQUFPO1lBQ0wsb0JBQW9CLEVBQUUsQ0FBQyxDQUFVLEVBQUUsQ0FBVyxFQUFtQixFQUFFO2dCQUNqRSxNQUFNLFVBQVUsR0FBRyw2QkFBNkIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7Z0JBQ3ZELElBQUksQ0FBQyxVQUFVLEVBQUU7b0JBQ2YsT0FBTztpQkFDUjtnQkFDRCxPQUFPO29CQUNMLE9BQU8sRUFBRSxDQUFDOzRCQUNSLFVBQVUsRUFBRSxDQUFDLENBQUMsYUFBYSxFQUFFOzRCQUM3QixLQUFLLEVBQUUsQ0FBQyxDQUFDLFFBQVEsRUFBRTs0QkFDbkIsR0FBRyxFQUFFLENBQUMsQ0FBQyxNQUFNLEVBQUU7NEJBQ2YsV0FBVyxFQUFFLFVBQVUsQ0FBQyxXQUFXO3lCQUNwQyxDQUFDO2lCQUNILENBQUM7WUFDSixDQUFDO1NBQ0YsQ0FBQztJQUNKLENBQUM7SUFuQkQsc0RBbUJDO0lBRUQsOEVBQThFO0lBQzlFLCtFQUErRTtJQUMvRSwwRUFBMEU7SUFDMUUsaUNBQWlDO0lBRWpDOzs7Ozs7T0FNRztJQUNILFNBQWdCLG1CQUFtQixDQUMvQixNQUFxQixFQUFFLFVBQWtCLEVBQUUsUUFBZ0IsRUFDM0QsUUFBaUIsRUFBRSxXQUFvQixFQUFFLENBQVc7UUFFdEQsTUFBTSxnQkFBZ0IsR0FBRyxNQUFNLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsbUJBQW1CLENBQUMsQ0FBQztRQUMxRSxNQUFNLGVBQWUsR0FDakIsUUFBUSxDQUFDLENBQUMsQ0FBQyxHQUFHLFVBQVUsT0FBTyxRQUFRLEVBQUUsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDO1FBRTNELEtBQUssTUFBTSxLQUFLLElBQUksZ0JBQWdCLEVBQUU7WUFDcEMsTUFBTSxVQUFVLEdBQUcsb0JBQW9CLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBQ2xELElBQUksQ0FBQyxVQUFVLElBQUksVUFBVSxDQUFDLFFBQVEsS0FBSyxRQUFRLEVBQUU7Z0JBQ25ELHdFQUF3RTtnQkFDeEUsU0FBUyxDQUFFLDJCQUEyQjthQUN2QztZQUNELElBQUksRUFBRSxDQUFDLGlCQUFpQixDQUFDLFVBQVUsQ0FBQyxhQUFhLENBQUMsRUFBRTtnQkFDbEQsb0JBQVEsQ0FBQyxDQUFDLEVBQUUsZ0NBQWdDLENBQUMsQ0FBQztnQkFDOUMsU0FBUyxDQUFFLDJCQUEyQjthQUN2QztZQUVELHdFQUF3RTtZQUN4RSx3Q0FBd0M7WUFDeEMsTUFBTSxnQkFBZ0IsR0FBRyxVQUFVLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQzNELEtBQUssQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLFlBQVksQ0FBQyxDQUFDO2dCQUN6QixLQUFLLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxLQUFLLFFBQVEsSUFBSyxzQkFBc0I7b0JBQ3hELEtBQUssQ0FBQyxZQUFZLENBQUMsT0FBTyxFQUFFLEtBQUssVUFBVSxDQUFDLENBQUM7Z0JBQ2pELEtBQUssQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLEtBQUssVUFBVSxDQUFDLENBQUMsQ0FBRSxlQUFlO1lBRTlELElBQUksZ0JBQWdCLEVBQUU7Z0JBQ3BCLG9CQUFRLENBQUMsQ0FBQyxFQUFFLElBQUksS0FBSyxDQUFDLFdBQVcsRUFBRSxhQUFhLFVBQVUsY0FBYyxDQUFDLENBQUM7Z0JBQzFFLE9BQU8sQ0FBRSx3REFBd0Q7YUFDbEU7WUFFRCxpRUFBaUU7WUFDakUsb0JBQVEsQ0FBQyxDQUFDLEVBQUUscURBQXFELENBQUMsQ0FBQztZQUNuRSxPQUFPO2dCQUNMLEtBQUssRUFBRSxVQUFVLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLEVBQUU7Z0JBQ3RELEdBQUcsRUFBRSxVQUFVLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLEVBQUU7Z0JBQ3BELFVBQVUsRUFBRSxNQUFNO2dCQUNsQixXQUFXLEVBQUUsR0FBRyxlQUFlLElBQUk7YUFDcEMsQ0FBQztTQUNIO1FBRUQsNEVBQTRFO1FBQzVFLG1FQUFtRTtRQUNuRSx3Q0FBd0M7UUFDeEMsTUFBTSxrQkFBa0IsR0FBRyxXQUFXLGVBQWUsV0FBVyxRQUFRLElBQUk7WUFDeEUsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLEtBQUssV0FBVyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ2hELE1BQU0saUJBQWlCLEdBQUcsZ0JBQWdCLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDL0MsZ0JBQWdCLENBQUMsZ0JBQWdCLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDLE1BQU0sRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQzVELENBQUMsQ0FBQztRQUNOLE9BQU87WUFDTCxLQUFLLEVBQUUsaUJBQWlCO1lBQ3hCLEdBQUcsRUFBRSxpQkFBaUI7WUFDdEIsVUFBVSxFQUFFLE1BQU07WUFDbEIsV0FBVyxFQUFFLGtCQUFrQjtTQUNoQyxDQUFDO0lBQ0osQ0FBQztJQXhERCxrREF3REM7SUFFRDs7Ozs7O09BTUc7SUFDSCxTQUFnQix1QkFBdUIsQ0FDbkMsTUFBcUIsRUFBRSxRQUFnQixFQUFFLFFBQWdCLEVBQ3pELFdBQW9CLEVBQUUsQ0FBVztRQUNuQyxNQUFNLGdCQUFnQixHQUFHLE1BQU0sQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO1FBRTFFLE1BQU0saUJBQWlCLEdBQUcsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQ3RELE1BQU0sVUFBVSxHQUFHLG9CQUFvQixDQUFDLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQztZQUNsRCxJQUFJLENBQUMsVUFBVSxJQUFJLFVBQVUsQ0FBQyxRQUFRLEtBQUssUUFBUSxFQUFFO2dCQUNuRCx3RUFBd0U7Z0JBQ3hFLE9BQU8sS0FBSyxDQUFDO2FBQ2Q7WUFDRCxvQkFBUSxDQUFDLENBQUMsRUFBRSxJQUFJLEtBQUssQ0FBQyxXQUFXLEVBQUUsb0NBQW9DLENBQUMsQ0FBQztZQUV6RSxJQUFJLEVBQUUsQ0FBQyxjQUFjLENBQUMsVUFBVSxDQUFDLGFBQWEsQ0FBQyxFQUFFO2dCQUMvQyxvQkFBUSxDQUFDLENBQUMsRUFBRSw2QkFBNkIsQ0FBQyxDQUFDO2dCQUMzQyxPQUFPLEtBQUssQ0FBQyxDQUFFLHNDQUFzQzthQUN0RDtZQUNELHVDQUF1QztZQUN2QyxJQUFJLFVBQVUsQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxLQUFLLFFBQVEsRUFBRTtnQkFDeEQsb0JBQVEsQ0FBQyxDQUFDLEVBQUUsaURBQWlELENBQUMsQ0FBQztnQkFDL0QsT0FBTyxLQUFLLENBQUM7YUFDZDtZQUNELG9CQUFRLENBQUMsQ0FBQyxFQUFFLDZDQUE2QyxDQUFDLENBQUM7WUFDM0QsT0FBTyxJQUFJLENBQUM7UUFDZCxDQUFDLENBQUMsQ0FBQztRQUVILElBQUksQ0FBQyxpQkFBaUIsRUFBRTtZQUN0QixNQUFNLGlCQUFpQixHQUFHLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxDQUFDO2dCQUMvQyxnQkFBZ0IsQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsTUFBTSxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUM7Z0JBQzVELENBQUMsQ0FBQztZQUNOLE9BQU87Z0JBQ0wsS0FBSyxFQUFFLGlCQUFpQjtnQkFDeEIsR0FBRyxFQUFFLGlCQUFpQjtnQkFDdEIsVUFBVSxFQUFFLE1BQU07Z0JBQ2xCLFdBQVcsRUFBRSxXQUFXLENBQUMsQ0FBQztvQkFDdEIsZUFBZSxRQUFRLFVBQVUsUUFBUSxPQUFPLFdBQVcsSUFBSSxDQUFDLENBQUM7b0JBQ2pFLGVBQWUsUUFBUSxVQUFVLFFBQVEsTUFBTTthQUNwRCxDQUFDO1NBQ0g7UUFDRCxPQUFPO0lBQ1QsQ0FBQztJQXhDRCwwREF3Q0M7SUFFRDs7OztPQUlHO0lBQ0gsU0FBUyxvQkFBb0IsQ0FBQyxLQUEyQixFQUFFLENBQVc7UUFJcEUsSUFBSSxDQUFDLEtBQUssQ0FBQyxZQUFZLEVBQUU7WUFDdkIsa0NBQWtDO1lBQ2xDLG9CQUFRLENBQ0osQ0FBQyxFQUFFLDRDQUE0QyxLQUFLLENBQUMsV0FBVyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1lBQzFFLE9BQU87U0FDUjtRQUNELElBQUksS0FBSyxDQUFDLFlBQVksQ0FBQyxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsWUFBWSxDQUFDLGFBQWEsRUFBRTtZQUNoRSxrRUFBa0U7WUFDbEUsMEVBQTBFO1lBQzFFLHFFQUFxRTtZQUNyRSxVQUFVO1lBQ1Ysb0JBQVEsQ0FBQyxDQUFDLEVBQUUsb0JBQW9CLEtBQUssQ0FBQyxXQUFXLEVBQUUsRUFBRSxDQUFDLENBQUM7WUFDdkQsT0FBTztTQUNSO1FBQ0QsSUFBSSxDQUFDLEVBQUUsQ0FBQyxlQUFlLENBQUMsS0FBSyxDQUFDLGVBQWUsQ0FBQyxFQUFFO1lBQzlDLG9CQUFRLENBQUMsQ0FBQyxFQUFFLHVEQUF1RCxDQUFDLENBQUM7WUFDckUsT0FBTztTQUNSO1FBQ0QsT0FBTztZQUNMLGFBQWEsRUFBRSxLQUFLLENBQUMsWUFBWSxDQUFDLGFBQWE7WUFDL0MsUUFBUSxFQUFFLEtBQUssQ0FBQyxlQUFlLENBQUMsSUFBSTtTQUNyQyxDQUFDO0lBQ0osQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHRzIGZyb20gJ3R5cGVzY3JpcHQnO1xuaW1wb3J0IHtGaXgsIEluZGl2aWR1YWxDaGFuZ2V9IGZyb20gJy4uL2ZhaWx1cmUnO1xuaW1wb3J0IHtkZWJ1Z0xvZ30gZnJvbSAnLi9hc3RfdG9vbHMnO1xuXG4vKipcbiAqIEEgRml4ZXIgdHVybnMgTm9kZXMgKHRoYXQgYXJlIHN1cHBvc2VkIHRvIGhhdmUgYmVlbiBtYXRjaGVkIGJlZm9yZSkgaW50byBhXG4gKiBGaXguIFRoaXMgaXMgbWVhbnQgdG8gYmUgaW1wbGVtZW50ZWQgYnkgUnVsZSBpbXBsZW1lbnRlcnMgKG9yXG4gKiBiYW4tcHJlc2V0LXBhdHRlcm4gdXNlcnMpLiBTZWUgYWxzbyBgYnVpbGRSZXBsYWNlbWVudEZpeGVyYCBmb3IgYSBzaW1wbGVyIHdheVxuICogb2YgaW1wbGVtZW50aW5nIGEgRml4ZXIuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRml4ZXI8Tm9kZVR5cGUgZXh0ZW5kcyB0cy5Ob2RlID0gdHMuTm9kZT4ge1xuICBnZXRGaXhGb3JGbGFnZ2VkTm9kZShub2RlOiBOb2RlVHlwZSwgdj86IGJvb2xlYW4pOiBGaXh8dW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEEgc2ltcGxlIEZpeGVyIGJ1aWxkZXIgYmFzZWQgb24gYSBmdW5jdGlvbiB0aGF0IGxvb2tzIGF0IGEgbm9kZSwgYW5kXG4gKiBvdXRwdXQgZWl0aGVyIG5vdGhpbmcsIG9yIGEgcmVwbGFjZW1lbnQuIElmIHRoaXMgaXMgdG9vIGxpbWl0aW5nLCBpbXBsZW1lbnRcbiAqIEZpeGVyIGluc3RlYWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWlsZFJlcGxhY2VtZW50Rml4ZXIoXG4gICAgcG90ZW50aWFsUmVwbGFjZW1lbnRHZW5lcmF0b3I6IChub2RlOiB0cy5Ob2RlLCB2PzogYm9vbGVhbikgPT5cbiAgICAgICAgKHtyZXBsYWNlV2l0aDogc3RyaW5nfSB8IHVuZGVmaW5lZCkpOiBGaXhlciB7XG4gIHJldHVybiB7XG4gICAgZ2V0Rml4Rm9yRmxhZ2dlZE5vZGU6IChuOiB0cy5Ob2RlLCB2PzogYm9vbGVhbik6IEZpeCB8IHVuZGVmaW5lZCA9PiB7XG4gICAgICBjb25zdCBwYXJ0aWFsRml4ID0gcG90ZW50aWFsUmVwbGFjZW1lbnRHZW5lcmF0b3Iobiwgdik7XG4gICAgICBpZiAoIXBhcnRpYWxGaXgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2hhbmdlczogW3tcbiAgICAgICAgICBzb3VyY2VGaWxlOiBuLmdldFNvdXJjZUZpbGUoKSxcbiAgICAgICAgICBzdGFydDogbi5nZXRTdGFydCgpLFxuICAgICAgICAgIGVuZDogbi5nZXRFbmQoKSxcbiAgICAgICAgICByZXBsYWNlbWVudDogcGFydGlhbEZpeC5yZXBsYWNlV2l0aCxcbiAgICAgICAgfV0sXG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gVE9ETyhyamFtZXQpOiBCb3RoIG1heWJlQWRkTmFtZWRJbXBvcnQgYW5kIG1heWJlQWRkTmFtZXNwYWNlZEltcG9ydCBhcmUgdG9vXG4vLyBoYXJkIHRvIHJlYWQgdG8gbXkgdGFzdGUuIFRoaXMgY291bGQgcHJvYmFibHkgYmUgaW1wcm92ZWQgdXBvbiBieSBiZWluZyBtb3JlXG4vLyBmdW5jdGlvbm5hbCwgdG8gc2hvdyB0aGUgZmlsdGVyIHBhc3NlcyBhbmQgZ2V0IHJpZCBvZiB0aGUgY29udGludWVzIGFuZFxuLy8gcmV0dXJucyAod2hpY2ggYXJlIGNvbmZ1c2luZykuXG5cbi8qKlxuICogQnVpbGRzIGFuIEluZGl2aWR1YWxDaGFuZ2UgdGhhdCBpbXBvcnRzIHRoZSByZXF1aXJlZCBzeW1ib2wgZnJvbSB0aGUgZ2l2ZW5cbiAqIGZpbGUgdW5kZXIgdGhlIGdpdmVuIG5hbWUuIFRoaXMgbWlnaHQgcmVpbXBvcnQgdGhlIHNhbWUgdGhpbmcgdHdpY2UgaW4gc29tZVxuICogY2FzZXMsIGJ1dCBpdCB3aWxsIGFsd2F5cyBtYWtlIGl0IGF2YWlsYWJsZSB1bmRlciB0aGUgcmlnaHQgbmFtZSAodGhvdWdoXG4gKiBpdHMgbmFtZSBtaWdodCBjb2xsaWRlIHdpdGggb3RoZXIgaW1wb3J0cywgYXMgd2UgZG9uJ3QgY3VycmVudGx5IGNoZWNrIGZvclxuICogdGhhdCkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXliZUFkZE5hbWVkSW1wb3J0KFxuICAgIHNvdXJjZTogdHMuU291cmNlRmlsZSwgaW1wb3J0V2hhdDogc3RyaW5nLCBmcm9tRmlsZTogc3RyaW5nLFxuICAgIGltcG9ydEFzPzogc3RyaW5nLCB0YXplQ29tbWVudD86IHN0cmluZywgdj86IGJvb2xlYW4pOiBJbmRpdmlkdWFsQ2hhbmdlfFxuICAgIHVuZGVmaW5lZCB7XG4gIGNvbnN0IGltcG9ydFN0YXRlbWVudHMgPSBzb3VyY2Uuc3RhdGVtZW50cy5maWx0ZXIodHMuaXNJbXBvcnREZWNsYXJhdGlvbik7XG4gIGNvbnN0IGltcG9ydFNwZWNpZmllciA9XG4gICAgICBpbXBvcnRBcyA/IGAke2ltcG9ydFdoYXR9IGFzICR7aW1wb3J0QXN9YCA6IGltcG9ydFdoYXQ7XG5cbiAgZm9yIChjb25zdCBpRGVjbCBvZiBpbXBvcnRTdGF0ZW1lbnRzKSB7XG4gICAgY29uc3QgcGFyc2VkRGVjbCA9IG1heWJlUGFyc2VJbXBvcnROb2RlKGlEZWNsLCB2KTtcbiAgICBpZiAoIXBhcnNlZERlY2wgfHwgcGFyc2VkRGVjbC5mcm9tRmlsZSAhPT0gZnJvbUZpbGUpIHtcbiAgICAgIC8vIE5vdCBhbiBpbXBvcnQgZnJvbSB0aGUgcmlnaHQgZmlsZSwgb3IgY291bGRuJ3QgdW5kZXJzdGFuZCB0aGUgaW1wb3J0LlxuICAgICAgY29udGludWU7ICAvLyBKdW1wIHRvIHRoZSBuZXh0IGltcG9ydC5cbiAgICB9XG4gICAgaWYgKHRzLmlzTmFtZXNwYWNlSW1wb3J0KHBhcnNlZERlY2wubmFtZWRCaW5kaW5ncykpIHtcbiAgICAgIGRlYnVnTG9nKHYsIGAuLi4gYnV0IGl0J3MgYSB3aWxkY2FyZCBpbXBvcnRgKTtcbiAgICAgIGNvbnRpbnVlOyAgLy8gSnVtcCB0byB0aGUgbmV4dCBpbXBvcnQuXG4gICAgfVxuXG4gICAgLy8gRWxzZSwgYmluZGluZ3MgaXMgYSBOYW1lZEltcG9ydHMuIFdlIGNhbiBub3cgc2VhcmNoIHdoZXRoZXIgdGhlIHJpZ2h0XG4gICAgLy8gc3ltYm9sIGlzIHRoZXJlIHVuZGVyIHRoZSByaWdodCBuYW1lLlxuICAgIGNvbnN0IGZvdW5kUmlnaHRJbXBvcnQgPSBwYXJzZWREZWNsLm5hbWVkQmluZGluZ3MuZWxlbWVudHMuc29tZShcbiAgICAgICAgaVNwZWMgPT4gaVNwZWMucHJvcGVydHlOYW1lID9cbiAgICAgICAgICAgIGlTcGVjLm5hbWUuZ2V0VGV4dCgpID09PSBpbXBvcnRBcyAmJiAgLy8gaW1wb3J0IHtmb28gYXMgYmFyfVxuICAgICAgICAgICAgICAgIGlTcGVjLnByb3BlcnR5TmFtZS5nZXRUZXh0KCkgPT09IGltcG9ydFdoYXQgOlxuICAgICAgICAgICAgaVNwZWMubmFtZS5nZXRUZXh0KCkgPT09IGltcG9ydFdoYXQpOyAgLy8gaW1wb3J0IHtmb299XG5cbiAgICBpZiAoZm91bmRSaWdodEltcG9ydCkge1xuICAgICAgZGVidWdMb2codiwgYFwiJHtpRGVjbC5nZXRGdWxsVGV4dCgpfVwiIGltcG9ydHMgJHtpbXBvcnRXaGF0fSBhcyB3ZSB3YW50LmApO1xuICAgICAgcmV0dXJuOyAgLy8gT3VyIHJlcXVlc3QgaXMgYWxyZWFkeSBpbXBvcnRlZCB1bmRlciB0aGUgcmlnaHQgbmFtZS5cbiAgICB9XG5cbiAgICAvLyBFbHNlLCBpbnNlcnQgb3VyIHN5bWJvbCBpbiB0aGUgbGlzdCBvZiBpbXBvcnRzIGZyb20gdGhhdCBmaWxlLlxuICAgIGRlYnVnTG9nKHYsIGBObyBuYW1lZCBpbXBvcnRzIGZyb20gdGhhdCBmaWxlLCBnZW5lcmF0aW5nIG5ldyBmaXhgKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnQ6IHBhcnNlZERlY2wubmFtZWRCaW5kaW5ncy5lbGVtZW50c1swXS5nZXRTdGFydCgpLFxuICAgICAgZW5kOiBwYXJzZWREZWNsLm5hbWVkQmluZGluZ3MuZWxlbWVudHNbMF0uZ2V0U3RhcnQoKSxcbiAgICAgIHNvdXJjZUZpbGU6IHNvdXJjZSxcbiAgICAgIHJlcGxhY2VtZW50OiBgJHtpbXBvcnRTcGVjaWZpZXJ9LCBgLFxuICAgIH07XG4gIH1cblxuICAvLyBJZiB3ZSBnZXQgaGVyZSwgd2UgZGlkbid0IGZpbmQgYW55dGhpbmcgaW1wb3J0ZWQgZnJvbSB0aGUgd2FudGVkIGZpbGUsIHNvXG4gIC8vIHdlJ2xsIG5lZWQgdGhlIGZ1bGwgaW1wb3J0IHN0cmluZy4gQWRkIGl0IGFmdGVyIHRoZSBsYXN0IGltcG9ydCxcbiAgLy8gYW5kIGxldCBjbGFuZy1mb3JtYXQgaGFuZGxlIHRoZSByZXN0LlxuICBjb25zdCBuZXdJbXBvcnRTdGF0ZW1lbnQgPSBgaW1wb3J0IHske2ltcG9ydFNwZWNpZmllcn19IGZyb20gJyR7ZnJvbUZpbGV9JztgICtcbiAgICAgICh0YXplQ29tbWVudCA/IGAgICR7dGF6ZUNvbW1lbnR9XFxuYCA6IGBcXG5gKTtcbiAgY29uc3QgaW5zZXJ0aW9uUG9zaXRpb24gPSBpbXBvcnRTdGF0ZW1lbnRzLmxlbmd0aCA/XG4gICAgICBpbXBvcnRTdGF0ZW1lbnRzW2ltcG9ydFN0YXRlbWVudHMubGVuZ3RoIC0gMV0uZ2V0RW5kKCkgKyAxIDpcbiAgICAgIDA7XG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IGluc2VydGlvblBvc2l0aW9uLFxuICAgIGVuZDogaW5zZXJ0aW9uUG9zaXRpb24sXG4gICAgc291cmNlRmlsZTogc291cmNlLFxuICAgIHJlcGxhY2VtZW50OiBuZXdJbXBvcnRTdGF0ZW1lbnQsXG4gIH07XG59XG5cbi8qKlxuICogQnVpbGRzIGFuIEluZGl2aWR1YWxDaGFuZ2UgdGhhdCBpbXBvcnRzIHRoZSByZXF1aXJlZCBuYW1lc3BhY2UgZnJvbSB0aGUgZ2l2ZW5cbiAqIGZpbGUgdW5kZXIgdGhlIGdpdmVuIG5hbWUuIFRoaXMgbWlnaHQgcmVpbXBvcnQgdGhlIHNhbWUgdGhpbmcgdHdpY2UgaW4gc29tZVxuICogY2FzZXMsIGJ1dCBpdCB3aWxsIGFsd2F5cyBtYWtlIGl0IGF2YWlsYWJsZSB1bmRlciB0aGUgcmlnaHQgbmFtZSAodGhvdWdoXG4gKiBpdHMgbmFtZSBtaWdodCBjb2xsaWRlIHdpdGggb3RoZXIgaW1wb3J0cywgYXMgd2UgZG9uJ3QgY3VycmVudGx5IGNoZWNrIGZvclxuICogdGhhdCkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXliZUFkZE5hbWVzcGFjZUltcG9ydChcbiAgICBzb3VyY2U6IHRzLlNvdXJjZUZpbGUsIGZyb21GaWxlOiBzdHJpbmcsIGltcG9ydEFzOiBzdHJpbmcsXG4gICAgdGF6ZUNvbW1lbnQ/OiBzdHJpbmcsIHY/OiBib29sZWFuKTogSW5kaXZpZHVhbENoYW5nZXx1bmRlZmluZWQge1xuICBjb25zdCBpbXBvcnRTdGF0ZW1lbnRzID0gc291cmNlLnN0YXRlbWVudHMuZmlsdGVyKHRzLmlzSW1wb3J0RGVjbGFyYXRpb24pO1xuXG4gIGNvbnN0IGhhc1RoZVJpZ2h0SW1wb3J0ID0gaW1wb3J0U3RhdGVtZW50cy5zb21lKGlEZWNsID0+IHtcbiAgICBjb25zdCBwYXJzZWREZWNsID0gbWF5YmVQYXJzZUltcG9ydE5vZGUoaURlY2wsIHYpO1xuICAgIGlmICghcGFyc2VkRGVjbCB8fCBwYXJzZWREZWNsLmZyb21GaWxlICE9PSBmcm9tRmlsZSkge1xuICAgICAgLy8gTm90IGFuIGltcG9ydCBmcm9tIHRoZSByaWdodCBmaWxlLCBvciBjb3VsZG4ndCB1bmRlcnN0YW5kIHRoZSBpbXBvcnQuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGRlYnVnTG9nKHYsIGBcIiR7aURlY2wuZ2V0RnVsbFRleHQoKX1cIiBpcyBhbiBpbXBvcnQgZnJvbSB0aGUgcmlnaHQgZmlsZWApO1xuXG4gICAgaWYgKHRzLmlzTmFtZWRJbXBvcnRzKHBhcnNlZERlY2wubmFtZWRCaW5kaW5ncykpIHtcbiAgICAgIGRlYnVnTG9nKHYsIGAuLi4gYnV0IGl0J3MgYSBuYW1lZCBpbXBvcnRgKTtcbiAgICAgIHJldHVybiBmYWxzZTsgIC8vIGlycmVsZXZhbnQgdG8gb3VyIG5hbWVzcGFjZSBpbXBvcnRzXG4gICAgfVxuICAgIC8vIEVsc2UsIGJpbmRpbmdzIGlzIGEgTmFtZXNwYWNlSW1wb3J0LlxuICAgIGlmIChwYXJzZWREZWNsLm5hbWVkQmluZGluZ3MubmFtZS5nZXRUZXh0KCkgIT09IGltcG9ydEFzKSB7XG4gICAgICBkZWJ1Z0xvZyh2LCBgLi4uIGJ1dCBub3QgdGhlIHJpZ2h0IG5hbWUsIHdlIG5lZWQgdG8gcmVpbXBvcnRgKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZGVidWdMb2codiwgYC4uLiBhbmQgdGhlIHJpZ2h0IG5hbWUsIG5vIG5lZWQgdG8gcmVpbXBvcnRgKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG5cbiAgaWYgKCFoYXNUaGVSaWdodEltcG9ydCkge1xuICAgIGNvbnN0IGluc2VydGlvblBvc2l0aW9uID0gaW1wb3J0U3RhdGVtZW50cy5sZW5ndGggP1xuICAgICAgICBpbXBvcnRTdGF0ZW1lbnRzW2ltcG9ydFN0YXRlbWVudHMubGVuZ3RoIC0gMV0uZ2V0RW5kKCkgKyAxIDpcbiAgICAgICAgMDtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnQ6IGluc2VydGlvblBvc2l0aW9uLFxuICAgICAgZW5kOiBpbnNlcnRpb25Qb3NpdGlvbixcbiAgICAgIHNvdXJjZUZpbGU6IHNvdXJjZSxcbiAgICAgIHJlcGxhY2VtZW50OiB0YXplQ29tbWVudCA/XG4gICAgICAgICAgYGltcG9ydCAqIGFzICR7aW1wb3J0QXN9IGZyb20gJyR7ZnJvbUZpbGV9JzsgICR7dGF6ZUNvbW1lbnR9XFxuYCA6XG4gICAgICAgICAgYGltcG9ydCAqIGFzICR7aW1wb3J0QXN9IGZyb20gJyR7ZnJvbUZpbGV9JztcXG5gLFxuICAgIH07XG4gIH1cbiAgcmV0dXJuO1xufVxuXG4vKipcbiAqIFRoaXMgdHJpZXMgdG8gbWFrZSBzZW5zZSBvZiBhbiBJbXBvcnREZWNsYXJhdGlvbiwgYW5kIHJldHVybnMgdGhlIGludGVyZXN0aW5nXG4gKiBwYXJ0cywgdW5kZWZpbmVkIGlmIHRoZSBpbXBvcnQgZGVjbGFyYXRpb24gaXMgdmFsaWQgYnV0IG5vdCB1bmRlcnN0YW5kYWJsZSBieVxuICogdGhlIGNoZWNrZXIuXG4gKi9cbmZ1bmN0aW9uIG1heWJlUGFyc2VJbXBvcnROb2RlKGlEZWNsOiB0cy5JbXBvcnREZWNsYXJhdGlvbiwgdj86IGJvb2xlYW4pOiB7XG4gIG5hbWVkQmluZGluZ3M6IHRzLk5hbWVkSW1wb3J0QmluZGluZ3N8dHMuTmFtZXNwYWNlSW1wb3J0LFxuICBmcm9tRmlsZTogc3RyaW5nXG59fHVuZGVmaW5lZCB7XG4gIGlmICghaURlY2wuaW1wb3J0Q2xhdXNlKSB7XG4gICAgLy8gc29tZXRoaW5nIGxpa2UgaW1wb3J0IFwiLi9maWxlXCI7XG4gICAgZGVidWdMb2coXG4gICAgICAgIHYsIGBJZ25vcmluZyBpbXBvcnQgd2l0aG91dCBpbXBvcnRlZCBzeW1ib2w6ICR7aURlY2wuZ2V0RnVsbFRleHQoKX1gKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGlEZWNsLmltcG9ydENsYXVzZS5uYW1lIHx8ICFpRGVjbC5pbXBvcnRDbGF1c2UubmFtZWRCaW5kaW5ncykge1xuICAgIC8vIFNlZW1zIHRvIGhhcHBlbiBpbiBkZWZhdWx0cyBpbXBvcnRzIGxpa2UgaW1wb3J0IEZvbyBmcm9tICdCYXInLlxuICAgIC8vIE5vdCBtdWNoIHdlIGNhbiBkbyB3aXRoIHRoYXQgd2hlbiB0cnlpbmcgdG8gZ2V0IGEgaG9sZCBvZiBzb21lIHN5bWJvbHMsXG4gICAgLy8gc28ganVzdCBpZ25vcmUgdGhhdCBsaW5lICh3b3JzdCBjYXNlLCB3ZSdsbCBzdWdnZXN0IGFub3RoZXIgaW1wb3J0XG4gICAgLy8gc3R5bGUpLlxuICAgIGRlYnVnTG9nKHYsIGBJZ25vcmluZyBpbXBvcnQ6ICR7aURlY2wuZ2V0RnVsbFRleHQoKX1gKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCF0cy5pc1N0cmluZ0xpdGVyYWwoaURlY2wubW9kdWxlU3BlY2lmaWVyKSkge1xuICAgIGRlYnVnTG9nKHYsIGBJZ25vcmluZyBpbXBvcnQgd2hvc2UgbW9kdWxlIHNwZWNpZmllciBpcyBub3QgbGl0ZXJhbGApO1xuICAgIHJldHVybjtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5hbWVkQmluZGluZ3M6IGlEZWNsLmltcG9ydENsYXVzZS5uYW1lZEJpbmRpbmdzLFxuICAgIGZyb21GaWxlOiBpRGVjbC5tb2R1bGVTcGVjaWZpZXIudGV4dFxuICB9O1xufVxuIl19