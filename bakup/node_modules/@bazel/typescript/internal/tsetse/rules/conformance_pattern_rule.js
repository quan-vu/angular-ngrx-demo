(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "../error_code", "../util/pattern_config", "../util/pattern_engines/property_write_engine"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const error_code_1 = require("../error_code");
    const pattern_config_1 = require("../util/pattern_config");
    exports.PatternKind = pattern_config_1.PatternKind;
    const property_write_engine_1 = require("../util/pattern_engines/property_write_engine");
    /**
     * Builds a Rule that matches a certain pattern, given as parameter, and
     * that can additionally run a suggested fix generator on the matches.
     *
     * This is templated, mostly to ensure the nodes that have been matched
     * correspond to what the Fixer expects.
     */
    class ConformancePatternRule {
        constructor(config, fixer, verbose) {
            this.code = error_code_1.ErrorCode.CONFORMANCE_PATTERN;
            // TODO(rjamet): This cheats a bit with the typing, as TS doesn't realize
            // that P is Config.kind.
            // tslint:disable-next-line:no-any See above.
            let engine;
            switch (config.kind) {
                case pattern_config_1.PatternKind.BANNED_PROPERTY_WRITE:
                    engine = new property_write_engine_1.PropertyWriteEngine(config, fixer, verbose);
                    break;
                default:
                    throw new Error('Config type not recognized, or not implemented yet.');
            }
            this.ruleName = `conformance-pattern-${config.kind}`;
            this.engine = engine;
        }
        register(checker) {
            this.engine.register(checker);
        }
    }
    exports.ConformancePatternRule = ConformancePatternRule;
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29uZm9ybWFuY2VfcGF0dGVybl9ydWxlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vZXh0ZXJuYWwvYnVpbGRfYmF6ZWxfcnVsZXNfdHlwZXNjcmlwdC9pbnRlcm5hbC90c2V0c2UvcnVsZXMvY29uZm9ybWFuY2VfcGF0dGVybl9ydWxlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0lBQ0EsOENBQXdDO0lBR3hDLDJEQUE2RTtJQStDckUsc0JBL0MwQiw0QkFBVyxDQStDMUI7SUE3Q25CLHlGQUFrRjtJQUVsRjs7Ozs7O09BTUc7SUFDSCxNQUFhLHNCQUFzQjtRQU9qQyxZQUNJLE1BQWlCLEVBQUUsS0FBa0MsRUFDckQsT0FBaUI7WUFOWixTQUFJLEdBQUcsc0JBQVMsQ0FBQyxtQkFBbUIsQ0FBQztZQU81Qyx5RUFBeUU7WUFDekUseUJBQXlCO1lBQ3pCLDZDQUE2QztZQUM3QyxJQUFJLE1BQTBCLENBQUM7WUFDL0IsUUFBUSxNQUFNLENBQUMsSUFBSSxFQUFFO2dCQUNuQixLQUFLLDRCQUFXLENBQUMscUJBQXFCO29CQUNwQyxNQUFNLEdBQUcsSUFBSSwyQ0FBbUIsQ0FBQyxNQUFNLEVBQUUsS0FBSyxFQUFFLE9BQU8sQ0FBQyxDQUFDO29CQUN6RCxNQUFNO2dCQUNSO29CQUNFLE1BQU0sSUFBSSxLQUFLLENBQUMscURBQXFELENBQUMsQ0FBQzthQUMxRTtZQUNELElBQUksQ0FBQyxRQUFRLEdBQUcsdUJBQXVCLE1BQU0sQ0FBQyxJQUFJLEVBQUUsQ0FBQztZQUNyRCxJQUFJLENBQUMsTUFBTSxHQUFHLE1BQTBCLENBQUM7UUFDM0MsQ0FBQztRQUVELFFBQVEsQ0FBQyxPQUFnQjtZQUN2QixJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUNoQyxDQUFDO0tBQ0Y7SUE1QkQsd0RBNEJDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtDaGVja2VyfSBmcm9tICcuLi9jaGVja2VyJztcbmltcG9ydCB7RXJyb3JDb2RlfSBmcm9tICcuLi9lcnJvcl9jb2RlJztcbmltcG9ydCB7QWJzdHJhY3RSdWxlfSBmcm9tICcuLi9ydWxlJztcbmltcG9ydCB7Rml4ZXJ9IGZyb20gJy4uL3V0aWwvZml4ZXInO1xuaW1wb3J0IHtDb25maWcsIE1hdGNoZWROb2RlVHlwZXMsIFBhdHRlcm5LaW5kfSBmcm9tICcuLi91dGlsL3BhdHRlcm5fY29uZmlnJztcbmltcG9ydCB7UGF0dGVybkVuZ2luZX0gZnJvbSAnLi4vdXRpbC9wYXR0ZXJuX2VuZ2luZXMvcGF0dGVybl9lbmdpbmUnO1xuaW1wb3J0IHtQcm9wZXJ0eVdyaXRlRW5naW5lfSBmcm9tICcuLi91dGlsL3BhdHRlcm5fZW5naW5lcy9wcm9wZXJ0eV93cml0ZV9lbmdpbmUnO1xuXG4vKipcbiAqIEJ1aWxkcyBhIFJ1bGUgdGhhdCBtYXRjaGVzIGEgY2VydGFpbiBwYXR0ZXJuLCBnaXZlbiBhcyBwYXJhbWV0ZXIsIGFuZFxuICogdGhhdCBjYW4gYWRkaXRpb25hbGx5IHJ1biBhIHN1Z2dlc3RlZCBmaXggZ2VuZXJhdG9yIG9uIHRoZSBtYXRjaGVzLlxuICpcbiAqIFRoaXMgaXMgdGVtcGxhdGVkLCBtb3N0bHkgdG8gZW5zdXJlIHRoZSBub2RlcyB0aGF0IGhhdmUgYmVlbiBtYXRjaGVkXG4gKiBjb3JyZXNwb25kIHRvIHdoYXQgdGhlIEZpeGVyIGV4cGVjdHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBDb25mb3JtYW5jZVBhdHRlcm5SdWxlPFAgZXh0ZW5kcyBQYXR0ZXJuS2luZD4gaW1wbGVtZW50c1xuICAgIEFic3RyYWN0UnVsZSB7XG4gIHJlYWRvbmx5IHJ1bGVOYW1lOiBzdHJpbmc7XG4gIHJlYWRvbmx5IGNvZGUgPSBFcnJvckNvZGUuQ09ORk9STUFOQ0VfUEFUVEVSTjtcblxuICBwcml2YXRlIHJlYWRvbmx5IGVuZ2luZTogUGF0dGVybkVuZ2luZTxQPjtcblxuICBjb25zdHJ1Y3RvcihcbiAgICAgIGNvbmZpZzogQ29uZmlnPFA+LCBmaXhlcj86IEZpeGVyPE1hdGNoZWROb2RlVHlwZXNbUF0+LFxuICAgICAgdmVyYm9zZT86IGJvb2xlYW4pIHtcbiAgICAvLyBUT0RPKHJqYW1ldCk6IFRoaXMgY2hlYXRzIGEgYml0IHdpdGggdGhlIHR5cGluZywgYXMgVFMgZG9lc24ndCByZWFsaXplXG4gICAgLy8gdGhhdCBQIGlzIENvbmZpZy5raW5kLlxuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnkgU2VlIGFib3ZlLlxuICAgIGxldCBlbmdpbmU6IFBhdHRlcm5FbmdpbmU8YW55PjtcbiAgICBzd2l0Y2ggKGNvbmZpZy5raW5kKSB7XG4gICAgICBjYXNlIFBhdHRlcm5LaW5kLkJBTk5FRF9QUk9QRVJUWV9XUklURTpcbiAgICAgICAgZW5naW5lID0gbmV3IFByb3BlcnR5V3JpdGVFbmdpbmUoY29uZmlnLCBmaXhlciwgdmVyYm9zZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb25maWcgdHlwZSBub3QgcmVjb2duaXplZCwgb3Igbm90IGltcGxlbWVudGVkIHlldC4nKTtcbiAgICB9XG4gICAgdGhpcy5ydWxlTmFtZSA9IGBjb25mb3JtYW5jZS1wYXR0ZXJuLSR7Y29uZmlnLmtpbmR9YDtcbiAgICB0aGlzLmVuZ2luZSA9IGVuZ2luZSBhcyBQYXR0ZXJuRW5naW5lPFA+O1xuICB9XG5cbiAgcmVnaXN0ZXIoY2hlY2tlcjogQ2hlY2tlcikge1xuICAgIHRoaXMuZW5naW5lLnJlZ2lzdGVyKGNoZWNrZXIpO1xuICB9XG59XG5cbi8vIFJlLWV4cG9ydGVkIGZvciBjb252ZW5pZW5jZSB3aGVuIGluc3RhbnRpYXRpbmcgcnVsZXMuXG4vKipcbiAqIFRoZSBsaXN0IG9mIHN1cHBvcnRlZCBwYXR0ZXJucyB1c2VhYmxlIGluIENvbmZvcm1hbmNlUGF0dGVyblJ1bGUuIFRoZVxuICogcGF0dGVybnMgd2hvc2UgbmFtZSBtYXRjaCBKU0NvbmZvcm1hbmNlIHBhdHRlcm5zIHNob3VsZCBiZWhhdmUgc2ltaWxhcmx5IChzZWVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGUvY2xvc3VyZS1jb21waWxlci93aWtpL0pTLUNvbmZvcm1hbmNlLUZyYW1ld29yaykuXG4gKi9cbmV4cG9ydCB7UGF0dGVybktpbmR9O1xuIl19