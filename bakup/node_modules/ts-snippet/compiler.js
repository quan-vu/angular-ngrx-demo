"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var ts = require("typescript");
var Compiler = (function () {
    function Compiler(compilerOptions, rootDirectory) {
        var _this = this;
        if (compilerOptions === void 0) { compilerOptions = {}; }
        if (rootDirectory === void 0) { rootDirectory = process.cwd(); }
        function normalize(path) {
            return path.replace(/\\/g, "/");
        }
        var _a = ts.convertCompilerOptionsFromJson(__assign({ moduleResolution: "node", skipLibCheck: true, target: "es2017" }, compilerOptions), normalize(rootDirectory)), errors = _a.errors, options = _a.options;
        var error = errors[0];
        if (error) {
            throw new Error(this.formatDiagnostic(error));
        }
        this._compilerOptions = options;
        this._files = {};
        var languageServiceHost = {
            directoryExists: ts.sys.directoryExists,
            fileExists: ts.sys.fileExists,
            getCompilationSettings: function () { return _this._compilerOptions; },
            getCurrentDirectory: function () { return normalize(rootDirectory); },
            getDefaultLibFileName: function (options) {
                return ts.getDefaultLibFilePath(options);
            },
            getScriptFileNames: function () { return Object.keys(_this._files); },
            getScriptSnapshot: function (fileName) {
                if (_this._files[fileName]) {
                    return ts.ScriptSnapshot.fromString(_this._files[fileName].content);
                }
                else if (ts.sys.fileExists(fileName)) {
                    return ts.ScriptSnapshot.fromString(ts.sys.readFile(fileName).toString());
                }
                return undefined;
            },
            getScriptVersion: function (fileName) {
                return (_this._files[fileName] && _this._files[fileName].version.toString());
            },
            readDirectory: ts.sys.readDirectory,
            readFile: ts.sys.readFile
        };
        this._languageService = ts.createLanguageService(languageServiceHost, ts.createDocumentRegistry());
    }
    Compiler.prototype.compile = function (files) {
        var _this = this;
        Object.keys(files).forEach(function (fileName) {
            if (!_this._files[fileName]) {
                _this._files[fileName] = { content: "", version: 0 };
            }
            _this._files[fileName].content = files[fileName];
            _this._files[fileName].version++;
        });
        var program = this._languageService.getProgram();
        if (!program) {
            throw new Error("No program.");
        }
        return program;
    };
    Compiler.prototype.formatDiagnostic = function (diagnostic) {
        var message = ts.flattenDiagnosticMessageText(diagnostic.messageText, "\n");
        if (diagnostic.file) {
            var _a = diagnostic.file.getLineAndCharacterOfPosition(diagnostic.start), line = _a.line, character = _a.character;
            return "Error " + diagnostic.file.fileName + " (" + (line + 1) + "," + (character +
                1) + "): " + message;
        }
        return "Error: " + message;
    };
    Compiler.prototype.getDiagnostics = function (fileName) {
        return this._languageService
            .getCompilerOptionsDiagnostics()
            .concat(this._languageService.getSyntacticDiagnostics(fileName))
            .concat(this._languageService.getSemanticDiagnostics(fileName));
    };
    return Compiler;
}());
exports.Compiler = Compiler;
