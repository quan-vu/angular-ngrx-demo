/**
 * @fileoverview This is a collection of smaller utility functions to operate on
 * a TypeScript AST, used by JSConformance rules and elsewhere.
 */
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "typescript"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const ts = require("typescript");
    /**
     * Returns `n`'s parents in order.
     */
    function parents(n) {
        const p = [];
        while (n.parent) {
            n = n.parent;
            p.push(n);
        }
        return p;
    }
    exports.parents = parents;
    /**
     * Searches for something satisfying the given test in `n` or its children.
     */
    function findInChildren(n, test) {
        let toExplore = [n];
        let cur;
        while (cur = toExplore.pop()) {
            if (test(cur)) {
                return true;
            }
            // Recurse
            toExplore = toExplore.concat(cur.getChildren());
        }
        return false;
    }
    exports.findInChildren = findInChildren;
    /**
     * Returns true if the pattern-based Rule should look at that node and consider
     * warning there. The goal is to make it easy to exclude on source files,
     * blocks, module declarations, JSDoc, lib.d.ts nodes, that kind of things.
     */
    function shouldExamineNode(n) {
        return !(ts.isBlock(n) || ts.isModuleBlock(n) || ts.isModuleDeclaration(n) ||
            ts.isSourceFile(n) || (n.parent && ts.isTypeNode(n.parent)) ||
            ts.isJSDoc(n) || isInStockLibraries(n));
    }
    exports.shouldExamineNode = shouldExamineNode;
    /**
     * Return whether the given declaration is ambient.
     */
    function isAmbientDeclaration(d) {
        return Boolean(d.modifiers &&
            d.modifiers.some(m => m.kind === ts.SyntaxKind.DeclareKeyword));
    }
    exports.isAmbientDeclaration = isAmbientDeclaration;
    /**
     * Return whether the given Node is (or is in) a library included as default.
     * We currently look for a node_modules/typescript/ prefix, but this could
     * be expanded if needed.
     */
    function isInStockLibraries(n) {
        const sourceFile = ts.isSourceFile(n) ? n : n.getSourceFile();
        if (sourceFile) {
            return sourceFile.fileName.indexOf('node_modules/typescript/') !== -1;
        }
        else {
            // the node is nowhere? Consider it as part of the core libs: we can't do
            // anything with it anyways, and it was likely included as default.
            return true;
        }
    }
    exports.isInStockLibraries = isInStockLibraries;
    /**
     * Turns the given Symbol into its non-aliased version (which could be itself).
     * Returns undefined if given an undefined Symbol (so you can call
     * `dealias(typeChecker.getSymbolAtLocation(node))`).
     */
    function dealias(symbol, tc) {
        if (!symbol) {
            return undefined;
        }
        if (symbol.getFlags() & (ts.SymbolFlags.Alias | ts.SymbolFlags.TypeAlias)) {
            return dealias(tc.getAliasedSymbol(symbol), tc);
        }
        return symbol;
    }
    exports.dealias = dealias;
    /**
     * Returns whether `n`'s parents are something indicating a type.
     */
    function isPartOfTypeDeclaration(n) {
        return [n, ...parents(n)].some(p => p.kind === ts.SyntaxKind.TypeReference ||
            p.kind === ts.SyntaxKind.TypeLiteral);
    }
    exports.isPartOfTypeDeclaration = isPartOfTypeDeclaration;
    /**
     * Returns whether `n` is under an import statement.
     */
    function isPartOfImportStatement(n) {
        return [n, ...parents(n)].some(p => p.kind === ts.SyntaxKind.ImportDeclaration);
    }
    exports.isPartOfImportStatement = isPartOfImportStatement;
    /**
     * Returns whether `n` is a declaration.
     */
    function isDeclaration(n) {
        return ts.isVariableDeclaration(n) || ts.isClassDeclaration(n) ||
            ts.isFunctionDeclaration(n) || ts.isMethodDeclaration(n) ||
            ts.isPropertyDeclaration(n) || ts.isVariableDeclarationList(n) ||
            ts.isInterfaceDeclaration(n) || ts.isTypeAliasDeclaration(n) ||
            ts.isEnumDeclaration(n) || ts.isModuleDeclaration(n) ||
            ts.isImportDeclaration(n) || ts.isImportEqualsDeclaration(n) ||
            ts.isExportDeclaration(n) || ts.isMissingDeclaration(n);
    }
    exports.isDeclaration = isDeclaration;
    /** Type guard for expressions that looks like property writes. */
    function isPropertyWriteExpression(node) {
        if (!ts.isBinaryExpression(node)) {
            return false;
        }
        if (node.operatorToken.getText().trim() !== '=') {
            return false;
        }
        if (!ts.isPropertyAccessExpression(node.left) ||
            node.left.expression.getFullText().trim() === '') {
            return false;
        }
        // TODO: Destructuring assigments aren't covered. This would be a potential
        // bypass, but I doubt we'd catch bugs, so fixing it seems low priority
        // overall.
        return true;
    }
    exports.isPropertyWriteExpression = isPropertyWriteExpression;
    /**
     * Debug helper.
     */
    function debugLog(verbose, msg) {
        if (verbose)
            console.info(msg);
    }
    exports.debugLog = debugLog;
    /**
     * If verbose, logs the given error that happened while walking n, with a
     * stacktrace.
     */
    function logASTWalkError(verbose, n, e) {
        let nodeText = `[error getting name for ${JSON.stringify(n)}]`;
        try {
            nodeText = '"' + n.getFullText().trim() + '"';
        }
        catch (_a) {
        }
        debugLog(verbose, `Walking node ${nodeText} failed with error ${e}.\n` +
            `Stacktrace:\n${e.stack}`);
    }
    exports.logASTWalkError = logASTWalkError;
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXN0X3Rvb2xzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vZXh0ZXJuYWwvYnVpbGRfYmF6ZWxfcnVsZXNfdHlwZXNjcmlwdC9pbnRlcm5hbC90c2V0c2UvdXRpbC9hc3RfdG9vbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7OztHQUdHOzs7Ozs7Ozs7Ozs7SUFFSCxpQ0FBaUM7SUFFakM7O09BRUc7SUFDSCxTQUFnQixPQUFPLENBQUMsQ0FBVTtRQUNoQyxNQUFNLENBQUMsR0FBRyxFQUFFLENBQUM7UUFDYixPQUFPLENBQUMsQ0FBQyxNQUFNLEVBQUU7WUFDZixDQUFDLEdBQUcsQ0FBQyxDQUFDLE1BQU0sQ0FBQztZQUNiLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDWDtRQUNELE9BQU8sQ0FBQyxDQUFDO0lBQ1gsQ0FBQztJQVBELDBCQU9DO0lBRUQ7O09BRUc7SUFDSCxTQUFnQixjQUFjLENBQzFCLENBQVUsRUFBRSxJQUE2QjtRQUMzQyxJQUFJLFNBQVMsR0FBYyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQy9CLElBQUksR0FBc0IsQ0FBQztRQUMzQixPQUFPLEdBQUcsR0FBRyxTQUFTLENBQUMsR0FBRyxFQUFFLEVBQUU7WUFDNUIsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUU7Z0JBQ2IsT0FBTyxJQUFJLENBQUM7YUFDYjtZQUNELFVBQVU7WUFDVixTQUFTLEdBQUcsU0FBUyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQztTQUNqRDtRQUNELE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQztJQVpELHdDQVlDO0lBRUQ7Ozs7T0FJRztJQUNILFNBQWdCLGlCQUFpQixDQUFDLENBQVU7UUFDMUMsT0FBTyxDQUFDLENBQ0osRUFBRSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUMsYUFBYSxDQUFDLENB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QUFPO1lBQUUsT0FBTyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNqQyxDQUFDO0lBRkQsNEJBRUM7SUFFRDs7O09BR0c7SUFDSCxTQUFnQixlQUFlLENBQUMsT0FBZ0IsRUFBRSxDQUFVLEVBQUUsQ0FBUTtRQUNwRSxJQUFJLFFBQVEsR0FBRywyQkFBMkIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDO1FBQy9ELElBQUk7WUFDRixRQUFRLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxJQUFJLEVBQUUsR0FBRyxHQUFHLENBQUM7U0FDL0M7UUFBQyxXQUFNO1NBQ1A7UUFDRCxRQUFRLENBQ0osT0FBTyxFQUNQLGdCQUFnQixRQUFRLHNCQUFzQixDQUFDLEtBQUs7WUFDaEQsZ0JBQWdCLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDO0lBQ3JDLENBQUM7SUFWRCwwQ0FVQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGVvdmVydmlldyBUaGlzIGlzIGEgY29sbGVjdGlvbiBvZiBzbWFsbGVyIHV0aWxpdHkgZnVuY3Rpb25zIHRvIG9wZXJhdGUgb25cbiAqIGEgVHlwZVNjcmlwdCBBU1QsIHVzZWQgYnkgSlNDb25mb3JtYW5jZSBydWxlcyBhbmQgZWxzZXdoZXJlLlxuICovXG5cbmltcG9ydCAqIGFzIHRzIGZyb20gJ3R5cGVzY3JpcHQnO1xuXG4vKipcbiAqIFJldHVybnMgYG5gJ3MgcGFyZW50cyBpbiBvcmRlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcmVudHMobjogdHMuTm9kZSk6IHRzLk5vZGVbXSB7XG4gIGNvbnN0IHAgPSBbXTtcbiAgd2hpbGUgKG4ucGFyZW50KSB7XG4gICAgbiA9IG4ucGFyZW50O1xuICAgIHAucHVzaChuKTtcbiAgfVxuICByZXR1cm4gcDtcbn1cblxuLyoqXG4gKiBTZWFyY2hlcyBmb3Igc29tZXRoaW5nIHNhdGlzZnlpbmcgdGhlIGdpdmVuIHRlc3QgaW4gYG5gIG9yIGl0cyBjaGlsZHJlbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmRJbkNoaWxkcmVuKFxuICAgIG46IHRzLk5vZGUsIHRlc3Q6IChuOiB0cy5Ob2RlKSA9PiBib29sZWFuKTogYm9vbGVhbiB7XG4gIGxldCB0b0V4cGxvcmU6IHRzLk5vZGVbXSA9IFtuXTtcbiAgbGV0IGN1cjogdHMuTm9kZXx1bmRlZmluZWQ7XG4gIHdoaWxlIChjdXIgPSB0b0V4cGxvcmUucG9wKCkpIHtcbiAgICBpZiAodGVzdChjdXIpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gUmVjdXJzZVxuICAgIHRvRXhwbG9yZSA9IHRvRXhwbG9yZS5jb25jYXQoY3VyLmdldENoaWxkcmVuKCkpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHBhdHRlcm4tYmFzZWQgUnVsZSBzaG91bGQgbG9vayBhdCB0aGF0IG5vZGUgYW5kIGNvbnNpZGVyXG4gKiB3YXJuaW5nIHRoZXJlLiBUaGUgZ29hbCBpcyB0byBtYWtlIGl0IGVhc3kgdG8gZXhjbHVkZSBvbiBzb3VyY2UgZmlsZXMsXG4gKiBibG9ja3MsIG1vZHVsZSBkZWNsYXJhdGlvbnMsIEpTRG9jLCBsaWIuZC50cyBub2RlcywgdGhhdCBraW5kIG9mIHRoaW5ncy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNob3VsZEV4YW1pbmVOb2RlKG46IHRzLk5vZGUpIHtcbiAgcmV0dXJuICEoXG4gICAgICB0cy5pc0Jsb2NrKG4pIHx8IHRzLmlzTW9kdWxlQmxvY2sobikgfHwgdHMuaXNNb2R1bGVEZWNsYXJhdGlvbihuKSB8fFxuICAgICAgdHMuaXNTb3VyY2VGaWxlKG4pIHx8IChuLnBhcmVudCAmJiB0cy5pc1R5cGVOb2RlKG4ucGFyZW50KSkgfHxcbiAgICAgIHRzLmlzSlNEb2MobikgfHwgaXNJblN0b2NrTGlicmFyaWVzKG4pKTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gd2hldGhlciB0aGUgZ2l2ZW4gZGVjbGFyYXRpb24gaXMgYW1iaWVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQW1iaWVudERlY2xhcmF0aW9uKGQ6IHRzLkRlY2xhcmF0aW9uKTogYm9vbGVhbiB7XG4gIHJldHVybiBCb29sZWFuKFxuICAgICAgZC5tb2RpZmllcnMgJiZcbiAgICAgIGQubW9kaWZpZXJzLnNvbWUobSA9PiBtLmtpbmQgPT09IHRzLlN5bnRheEtpbmQuRGVjbGFyZUtleXdvcmQpKTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gd2hldGhlciB0aGUgZ2l2ZW4gTm9kZSBpcyAob3IgaXMgaW4pIGEgbGlicmFyeSBpbmNsdWRlZCBhcyBkZWZhdWx0LlxuICogV2UgY3VycmVudGx5IGxvb2sgZm9yIGEgbm9kZV9tb2R1bGVzL3R5cGVzY3JpcHQvIHByZWZpeCwgYnV0IHRoaXMgY291bGRcbiAqIGJlIGV4cGFuZGVkIGlmIG5lZWRlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzSW5TdG9ja0xpYnJhcmllcyhuOiB0cy5Ob2RlfHRzLlNvdXJjZUZpbGUpOiBib29sZWFuIHtcbiAgY29uc3Qgc291cmNlRmlsZSA9IHRzLmlzU291cmNlRmlsZShuKSA/IG4gOiBuLmdldFNvdXJjZUZpbGUoKTtcbiAgaWYgKHNvdXJjZUZpbGUpIHtcbiAgICByZXR1cm4gc291cmNlRmlsZS5maWxlTmFtZS5pbmRleE9mKCdub2RlX21vZHVsZXMvdHlwZXNjcmlwdC8nKSAhPT0gLTE7XG4gIH0gZWxzZSB7XG4gICAgLy8gdGhlIG5vZGUgaXMgbm93aGVyZT8gQ29uc2lkZXIgaXQgYXMgcGFydCBvZiB0aGUgY29yZSBsaWJzOiB3ZSBjYW4ndCBkb1xuICAgIC8vIGFueXRoaW5nIHdpdGggaXQgYW55d2F5cywgYW5kIGl0IHdhcyBsaWtlbHkgaW5jbHVkZWQgYXMgZGVmYXVsdC5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG4vKipcbiAqIFR1cm5zIHRoZSBnaXZlbiBTeW1ib2wgaW50byBpdHMgbm9uLWFsaWFzZWQgdmVyc2lvbiAod2hpY2ggY291bGQgYmUgaXRzZWxmKS5cbiAqIFJldHVybnMgdW5kZWZpbmVkIGlmIGdpdmVuIGFuIHVuZGVmaW5lZCBTeW1ib2wgKHNvIHlvdSBjYW4gY2FsbFxuICogYGRlYWxpYXModHlwZUNoZWNrZXIuZ2V0U3ltYm9sQXRMb2NhdGlvbihub2RlKSlgKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlYWxpYXMoXG4gICAgc3ltYm9sOiB0cy5TeW1ib2x8dW5kZWZpbmVkLCB0YzogdHMuVHlwZUNoZWNrZXIpOiB0cy5TeW1ib2x8dW5kZWZpbmVkIHtcbiAgaWYgKCFzeW1ib2wpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGlmIChzeW1ib2wuZ2V0RmxhZ3MoKSAmICh0cy5TeW1ib2xGbGFncy5BbGlhcyB8IHRzLlN5bWJvbEZsYWdzLlR5cGVBbGlhcykpIHtcbiAgICByZXR1cm4gZGVhbGlhcyh0Yy5nZXRBbGlhc2VkU3ltYm9sKHN5bWJvbCksIHRjKTtcbiAgfVxuICByZXR1cm4gc3ltYm9sO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBgbmAncyBwYXJlbnRzIGFyZSBzb21ldGhpbmcgaW5kaWNhdGluZyBhIHR5cGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1BhcnRPZlR5cGVEZWNsYXJhdGlvbihuOiB0cy5Ob2RlKSB7XG4gIHJldHVybiBbbiwgLi4ucGFyZW50cyhuKV0uc29tZShcbiAgICAgIHAgPT4gcC5raW5kID09PSB0cy5TeW50YXhLaW5kLlR5cGVSZWZlcmVuY2UgfHxcbiAgICAgICAgICBwLmtpbmQgPT09IHRzLlN5bnRheEtpbmQuVHlwZUxpdGVyYWwpO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBgbmAgaXMgdW5kZXIgYW4gaW1wb3J0IHN0YXRlbWVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzUGFydE9mSW1wb3J0U3RhdGVtZW50KG46IHRzLk5vZGUpIHtcbiAgcmV0dXJuIFtuLCAuLi5wYXJlbnRzKG4pXS5zb21lKFxuICAgICAgcCA9PiBwLmtpbmQgPT09IHRzLlN5bnRheEtpbmQuSW1wb3J0RGVjbGFyYXRpb24pO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBgbmAgaXMgYSBkZWNsYXJhdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRGVjbGFyYXRpb24objogdHMuTm9kZSk6IG4gaXMgdHMuVmFyaWFibGVEZWNsYXJhdGlvbnxcbiAgICB0cy5DbGFzc0RlY2xhcmF0aW9ufHRzLkZ1bmN0aW9uRGVjbGFyYXRpb258dHMuTWV0aG9kRGVjbGFyYXRpb258XG4gICAgdHMuUHJvcGVydHlEZWNsYXJhdGlvbnx0cy5WYXJpYWJsZURlY2xhcmF0aW9uTGlzdHx0cy5JbnRlcmZhY2VEZWNsYXJhdGlvbnxcbiAgICB0cy5UeXBlQWxpYXNEZWNsYXJhdGlvbnx0cy5FbnVtRGVjbGFyYXRpb258dHMuTW9kdWxlRGVjbGFyYXRpb258XG4gICAgdHMuSW1wb3J0RGVjbGFyYXRpb258dHMuSW1wb3J0RXF1YWxzRGVjbGFyYXRpb258dHMuRXhwb3J0RGVjbGFyYXRpb258XG4gICAgdHMuTWlzc2luZ0RlY2xhcmF0aW9uIHtcbiAgcmV0dXJuIHRzLmlzVmFyaWFibGVEZWNsYXJhdGlvbihuKSB8fCB0cy5pc0NsYXNzRGVjbGFyYXRpb24obikgfHxcbiAgICAgIHRzLmlzRnVuY3Rpb25EZWNsYXJhdGlvbihuKSB8fCB0cy5pc01ldGhvZERlY2xhcmF0aW9uKG4pIHx8XG4gICAgICB0cy5pc1Byb3BlcnR5RGVjbGFyYXRpb24obikgfHwgdHMuaXNWYXJpYWJsZURlY2xhcmF0aW9uTGlzdChuKSB8fFxuICAgICAgdHMuaXNJbnRlcmZhY2VEZWNsYXJhdGlvbihuKSB8fCB0cy5pc1R5cGVBbGlhc0RlY2xhcmF0aW9uKG4pIHx8XG4gICAgICB0cy5pc0VudW1EZWNsYXJhdGlvbihuKSB8fCB0cy5pc01vZHVsZURlY2xhcmF0aW9uKG4pIHx8XG4gICAgICB0cy5pc0ltcG9ydERlY2xhcmF0aW9uKG4pIHx8IHRzLmlzSW1wb3J0RXF1YWxzRGVjbGFyYXRpb24obikgfHxcbiAgICAgIHRzLmlzRXhwb3J0RGVjbGFyYXRpb24obikgfHwgdHMuaXNNaXNzaW5nRGVjbGFyYXRpb24obik7XG59XG5cbi8qKiBUeXBlIGd1YXJkIGZvciBleHByZXNzaW9ucyB0aGF0IGxvb2tzIGxpa2UgcHJvcGVydHkgd3JpdGVzLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzUHJvcGVydHlXcml0ZUV4cHJlc3Npb24obm9kZTogdHMuTm9kZSk6XG4gICAgbm9kZSBpcyh0cy5CaW5hcnlFeHByZXNzaW9uICYge1xuICAgICAgbGVmdDogdHMuUHJvcGVydHlBY2Nlc3NFeHByZXNzaW9uO1xuICAgIH0pIHtcbiAgaWYgKCF0cy5pc0JpbmFyeUV4cHJlc3Npb24obm9kZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKG5vZGUub3BlcmF0b3JUb2tlbi5nZXRUZXh0KCkudHJpbSgpICE9PSAnPScpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCF0cy5pc1Byb3BlcnR5QWNjZXNzRXhwcmVzc2lvbihub2RlLmxlZnQpIHx8XG4gICAgICBub2RlLmxlZnQuZXhwcmVzc2lvbi5nZXRGdWxsVGV4dCgpLnRyaW0oKSA9PT0gJycpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBUT0RPOiBEZXN0cnVjdHVyaW5nIGFzc2lnbWVudHMgYXJlbid0IGNvdmVyZWQuIFRoaXMgd291bGQgYmUgYSBwb3RlbnRpYWxcbiAgLy8gYnlwYXNzLCBidXQgSSBkb3VidCB3ZSdkIGNhdGNoIGJ1Z3MsIHNvIGZpeGluZyBpdCBzZWVtcyBsb3cgcHJpb3JpdHlcbiAgLy8gb3ZlcmFsbC5cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBEZWJ1ZyBoZWxwZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWJ1Z0xvZyh2ZXJib3NlOiBib29sZWFufHVuZGVmaW5lZCwgbXNnOiBzdHJpbmcpIHtcbiAgaWYgKHZlcmJvc2UpIGNvbnNvbGUuaW5mbyhtc2cpO1xufVxuXG4vKipcbiAqIElmIHZlcmJvc2UsIGxvZ3MgdGhlIGdpdmVuIGVycm9yIHRoYXQgaGFwcGVuZWQgd2hpbGUgd2Fsa2luZyBuLCB3aXRoIGFcbiAqIHN0YWNrdHJhY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb2dBU1RXYWxrRXJyb3IodmVyYm9zZTogYm9vbGVhbiwgbjogdHMuTm9kZSwgZTogRXJyb3IpIHtcbiAgbGV0IG5vZGVUZXh0ID0gYFtlcnJvciBnZXR0aW5nIG5hbWUgZm9yICR7SlNPTi5zdHJpbmdpZnkobil9XWA7XG4gIHRyeSB7XG4gICAgbm9kZVRleHQgPSAnXCInICsgbi5nZXRGdWxsVGV4dCgpLnRyaW0oKSArICdcIic7XG4gIH0gY2F0Y2gge1xuICB9XG4gIGRlYnVnTG9nKFxuICAgICAgdmVyYm9zZSxcbiAgICAgIGBXYWxraW5nIG5vZGUgJHtub2RlVGV4dH0gZmFpbGVkIHdpdGggZXJyb3IgJHtlfS5cXG5gICtcbiAgICAgICAgICBgU3RhY2t0cmFjZTpcXG4ke2Uuc3RhY2t9YCk7XG59XG4iXX0=