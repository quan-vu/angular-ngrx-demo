(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "./ast_tools"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const ast_tools_1 = require("./ast_tools");
    const JS_IDENTIFIER_FORMAT = '[\\w\\d_-]+';
    const FQN_FORMAT = `(${JS_IDENTIFIER_FORMAT}\.)*${JS_IDENTIFIER_FORMAT}`;
    // A fqn made out of a dot-separated chain of JS identifiers.
    const ABSOLUTE_RE = new RegExp(`^${FQN_FORMAT}$`);
    /**
     * This class matches symbols given a "foo.bar.baz" name, where none of the
     * steps are instances of classes.
     */
    class AbsoluteMatcher {
        /**
         * From a "path/to/file.ts:foo.bar.baz" or "foo.bar.baz" matcher
         * specification, builds a Matcher.
         */
        constructor(bannedName) {
            this.bannedName = bannedName;
            if (!bannedName.match(ABSOLUTE_RE)) {
                throw new Error('Malformed matcher selector.');
            }
            // JSConformance used to use a Foo.prototype.bar syntax for bar on
            // instances of Foo. TS doesn't surface the prototype part in the FQN, and
            // so you can't tell static `bar` on `foo` from the `bar` property/method
            // on `foo`. To avoid any confusion, throw there if we see `prototype` in
            // the spec: that way, it's obvious that you're not trying to match
            // properties.
            if (this.bannedName.includes('.prototype')) {
                throw new Error('Your pattern includes a .prototype, but the AbsoluteMatcher is ' +
                    'meant for non-object matches. Use the PropertyMatcher instead.');
            }
        }
        matches(n, tc, verbose) {
            // Get the symbol (or the one at the other end of this alias) that we're
            // looking at.
            const s = ast_tools_1.dealias(tc.getSymbolAtLocation(n), tc);
            if (!s) {
                ast_tools_1.debugLog(verbose, `cannot get symbol`);
                return false;
            }
            // The TS-provided FQN tells us the full identifier, and the origin file
            // in some circumstances.
            const fqn = tc.getFullyQualifiedName(s);
            ast_tools_1.debugLog(verbose, `got FQN ${fqn}`);
            // Name-based check
            if (!(fqn.endsWith('.' + this.bannedName) || fqn === this.bannedName)) {
                ast_tools_1.debugLog(verbose, `FQN ${fqn} doesn't match name ${this.bannedName}`);
                return false; // not a use of the symbols we want
            }
            // Check if it's part of a declaration or import. The check is cheap. If
            // we're looking for the uses of a symbol, we don't alert on the imports, to
            // avoid flooding users with warnings (as the actual use will be alerted)
            // and bad fixes.
            const p = n.parent;
            if (p && (ast_tools_1.isDeclaration(p) || ast_tools_1.isPartOfImportStatement(p))) {
                ast_tools_1.debugLog(verbose, `We don't flag symbol declarations`);
                return false;
            }
            // No file info in the FQN means it's not explicitly imported.
            // That must therefore be a local variable, or an ambient symbol
            // (and we only care about ambients here). Those could come from
            // either a declare somewhere, or one of the core libraries that
            // are loaded by default.
            if (!fqn.startsWith('"')) {
                // We need to trace things back, so get declarations of the symbol.
                const declarations = s.getDeclarations();
                if (!declarations) {
                    ast_tools_1.debugLog(verbose, `Symbol never declared?`);
                    return false;
                }
                if (!declarations.some(ast_tools_1.isAmbientDeclaration) &&
                    !declarations.some(ast_tools_1.isInStockLibraries)) {
                    ast_tools_1.debugLog(verbose, `Symbol neither ambient nor from the stock libraries`);
                    return false;
                }
            }
            ast_tools_1.debugLog(verbose, `all clear, report finding`);
            return true;
        }
    }
    exports.AbsoluteMatcher = AbsoluteMatcher;
    // TODO: Export the matched node kinds here.
    /**
     * This class matches a property access node, based on a property holder type
     * (through its name), i.e. a class, and a property name.
     *
     * The logic is voluntarily simple: if a matcher for `a.b` tests a `x.y` node,
     * it will return true if:
     * - `x` is of type `a` either directly (name-based) or through inheritance
     *   (ditto),
     * - and, textually, `y` === `b`.
     *
     * Note that the logic is different from TS's type system: this matcher doesn't
     * have any knowledge of structural typing.
     */
    class PropertyMatcher {
        constructor(bannedType, bannedProperty) {
            this.bannedType = bannedType;
            this.bannedProperty = bannedProperty;
        }
        static fromSpec(spec) {
            if (spec.indexOf('.prototype.') === -1) {
                throw new Error(`BANNED_PROPERTY expects a .prototype in your query.`);
            }
            const requestParser = /^([\w\d_.-]+)\.prototype\.([\w\d_.-]+)$/;
            const matches = requestParser.exec(spec);
            if (!matches) {
                throw new Error('Cannot understand the BannedProperty spec' + spec);
            }
            const [bannedType, bannedProperty] = matches.slice(1);
            return new PropertyMatcher(bannedType, bannedProperty);
        }
        /**
         * @param n The PropertyAccessExpression we're looking at.
         */
        matches(n, tc, verbose) {
            return n.name.text === this.bannedProperty &&
                this.typeMatches(tc.getTypeAtLocation(n.expression));
        }
        exactTypeMatches(inspectedType) {
            const typeSymbol = inspectedType.getSymbol() || false;
            return typeSymbol && typeSymbol.getName() === this.bannedType;
        }
        // TODO: Account for unknown types/ '?', and 'loose type matches', i.e. if the
        // actual type is a supertype of the prohibited type.
        typeMatches(inspectedType) {
            if (this.exactTypeMatches(inspectedType)) {
                return true;
            }
            const baseTypes = inspectedType.getBaseTypes() || [];
            return baseTypes.some(base => this.exactTypeMatches(base));
        }
    }
    exports.PropertyMatcher = PropertyMatcher;
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWF0Y2hfc3ltYm9sLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vZXh0ZXJuYWwvYnVpbGRfYmF6ZWxfcnVsZXNfdHlwZXNjcmlwdC9pbnRlcm5hbC90c2V0c2UvdXRpbC9tYXRjaF9zeW1ib2wudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7SUFHQSwyQ0FBZ0k7SUFFaEksTUFBTSxvQkFBb0IsR0FBRyxhQUFhLENBQUM7SUFDM0MsTUFBTSxVQUFVLEdBQUcsSUFBSSxvQkFBb0IsT0FBTyxvQkFBb0IsRUFBRSxDQUFDO0lBQ3pFLDZEQUE2RDtJQUM3RCxNQUFNLFdBQVcsR0FBRyxJQUFJLE1BQU0sQ0FBQyxJQUFJLFVBQVUsR0FBRyxDQUFDLENBQUM7SUFFbEQ7OztPQUdHO0lBQ0gsTUFBYSxlQUFlO1FBQzFCOzs7V0FHRztRQUNILFlBQXFCLFVBQWtCO1lBQWxCLGVBQVUsR0FBVixVQUFVLENBQVE7WUFDckMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLEVBQUU7Z0JBQ2xDLE1BQU0sSUFBSSxLQUFLLENBQUMsNkJBQTZCLENBQUMsQ0FBQzthQUNoRDtZQUVELGtFQUFrRTtZQUNsRSwwRUFBMEU7WUFDMUUseUVBQXlFO1lBQ3pFLHlFQUF5RTtZQUN6RSxtRUFBbUU7WUFDbkUsY0FBYztZQUNkLElBQUksSUFBSSxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsWUFBWSxDQUFDLEVBQUU7Z0JBQzFDLE1BQU0sSUFBSSxLQUFLLENBQ1gsaUVBQWlFO29CQUNqRSxnRUFBZ0UsQ0FBQyxDQUFDO2FBQ3ZFO1FBQ0gsQ0FBQztRQUVELE9BQU8sQ0FBQyxDQUFVLEVBQUUsRUFBa0IsRUFBRSxPQUFpQjtZQUN2RCx3RUFBd0U7WUFDeEUsY0FBYztZQUNkLE1BQU0sQ0FBQyxHQUFHLG1CQUFPLENBQUMsRUFBRSxDQUFDLG1CQUFtQixDQUFDLENBQUMsQ0FBQyxFQUFFLEVB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Q0FBQztZQUN0RCxPQUFPLElBQUksZUFBZSxDQUFDLFVBQVUsRUFBRSxjQUFjLENBQUMsQ0FBQztRQUN6RCxDQUFDO1FBSUQ7O1dBRUc7UUFDSCxPQUFPLENBQ0gsQ0FBOEIsRUFBRSxFQUFrQixFQUFFLE9BQWlCO1lBQ3ZFLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLEtBQUssSUFBSSxDQUFDLGNBQWM7Z0JBQ3RDLElBQUksQ0FBQyxXQUFXLENBQUMsRUFBRSxDQUFDLGlCQUFpQixDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDO1FBQzNELENBQUM7UUFFTyxnQkFBZ0IsQ0FBQyxhQUFzQjtZQUM3QyxNQUFNLFVBQVUsR0FBRyxhQUFhLENBQUMsU0FBUyxFQUFFLElBQUksS0FBSyxDQUFDO1lBQ3RELE9BQU8sVUFBVSxJQUFJLFVBQVUsQ0FBQyxPQUFPLEVBQUUsS0FBSyxJQUFJLENBQUMsVUFBVSxDQUFDO1FBQ2hFLENBQUM7UUFFRCw4RUFBOEU7UUFDOUUscURBQXFEO1FBQzdDLFdBQVcsQ0FBQyxhQUFzQjtZQUN4QyxJQUFJLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxhQUFhLENBQUMsRUFBRTtnQkFDeEMsT0FBTyxJQUFJLENBQUM7YUFDYjtZQUNELE1BQU0sU0FBUyxHQUFHLGFBQWEsQ0FBQyxZQUFZLEVBQUUsSUFBSSxFQUFFLENBQUM7WUFDckQsT0FBTyxTQUFTLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7UUFDN0QsQ0FBQztLQUNGO0lBdkNELDBDQXVDQyIsInNvdXJjZXNDb250ZW50IjpbIlxuXG5pbXBvcnQgKiBhcyB0cyBmcm9tICd0eXBlc2NyaXB0JztcbmltcG9ydCB7ZGVhbGlhcywgZGVidWdMb2csIGlzQW1iaWVudERlY2xhcmF0aW9uLCBpc0RlY2xhcmF0aW9uLCBpc0luU3RvY2tMaWJyYXJpZXMsIGlzUGFydE9mSW1wb3J0U3RhdGVtZW50fSBmcm9tICcuL2FzdF90b29scyc7XG5cbmNvbnN0IEpTX0lERU5USUZJRVJfRk9STUFUID0gJ1tcXFxcd1xcXFxkXy1dKyc7XG5jb25zdCBGUU5fRk9STUFUID0gYCgke0pTX0lERU5USUZJRVJfRk9STUFUfVxcLikqJHtKU19JREVOVElGSUVSX0ZPUk1BVH1gO1xuLy8gQSBmcW4gbWFkZSBvdXQgb2YgYSBkb3Qtc2VwYXJhdGVkIGNoYWluIG9mIEpTIGlkZW50aWZpZXJzLlxuY29uc3QgQUJTT0xVVEVfUkUgPSBuZXcgUmVnRXhwKGBeJHtGUU5fRk9STUFUfSRgKTtcblxuLyoqXG4gKiBUaGlzIGNsYXNzIG1hdGNoZXMgc3ltYm9scyBnaXZlbiBhIFwiZm9vLmJhci5iYXpcIiBuYW1lLCB3aGVyZSBub25lIG9mIHRoZVxuICogc3RlcHMgYXJlIGluc3RhbmNlcyBvZiBjbGFzc2VzLlxuICovXG5leHBvcnQgY2xhc3MgQWJzb2x1dGVNYXRjaGVyIHtcbiAgLyoqXG4gICAqIEZyb20gYSBcInBhdGgvdG8vZmlsZS50czpmb28uYmFyLmJhelwiIG9yIFwiZm9vLmJhci5iYXpcIiBtYXRjaGVyXG4gICAqIHNwZWNpZmljYXRpb24sIGJ1aWxkcyBhIE1hdGNoZXIuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihyZWFkb25seSBiYW5uZWROYW1lOiBzdHJpbmcpIHtcbiAgICBpZiAoIWJhbm5lZE5hbWUubWF0Y2goQUJTT0xVVEVfUkUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hbGZvcm1lZCBtYXRjaGVyIHNlbGVjdG9yLicpO1xuICAgIH1cblxuICAgIC8vIEpTQ29uZm9ybWFuY2UgdXNlZCB0byB1c2UgYSBGb28ucHJvdG90eXBlLmJhciBzeW50YXggZm9yIGJhciBvblxuICAgIC8vIGluc3RhbmNlcyBvZiBGb28uIFRTIGRvZXNuJ3Qgc3VyZmFjZSB0aGUgcHJvdG90eXBlIHBhcnQgaW4gdGhlIEZRTiwgYW5kXG4gICAgLy8gc28geW91IGNhbid0IHRlbGwgc3RhdGljIGBiYXJgIG9uIGBmb29gIGZyb20gdGhlIGBiYXJgIHByb3BlcnR5L21ldGhvZFxuICAgIC8vIG9uIGBmb29gLiBUbyBhdm9pZCBhbnkgY29uZnVzaW9uLCB0aHJvdyB0aGVyZSBpZiB3ZSBzZWUgYHByb3RvdHlwZWAgaW5cbiAgICAvLyB0aGUgc3BlYzogdGhhdCB3YXksIGl0J3Mgb2J2aW91cyB0aGF0IHlvdSdyZSBub3QgdHJ5aW5nIHRvIG1hdGNoXG4gICAgLy8gcHJvcGVydGllcy5cbiAgICBpZiAodGhpcy5iYW5uZWROYW1lLmluY2x1ZGVzKCcucHJvdG90eXBlJykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnWW91ciBwYXR0ZXJuIGluY2x1ZGVzIGEgLnByb3RvdHlwZSwgYnV0IHRoZSBBYnNvbHV0ZU1hdGNoZXIgaXMgJyArXG4gICAgICAgICAgJ21lYW50IGZvciBub24tb2JqZWN0IG1hdGNoZXMuIFVzZSB0aGUgUHJvcGVydHlNYXRjaGVyIGluc3RlYWQuJyk7XG4gICAgfVxuICB9XG5cbiAgbWF0Y2hlcyhuOiB0cy5Ob2RlLCB0YzogdHMuVHlwZUNoZWNrZXIsIHZlcmJvc2U/OiBib29sZWFuKTogYm9vbGVhbiB7XG4gICAgLy8gR2V0IHRoZSBzeW1ib2wgKG9yIHRoZSBvbmUgYXQgdGhlIG90aGVyIGVuZCBvZiB0aGlzIGFsaWFzKSB0aGF0IHdlJ3JlXG4gICAgLy8gbG9va2luZyBhdC5cbiAgICBjb25zdCBzID0gZGVhbGlhcyh0Yy5nZXRTeW1ib2xBdExvY2F0aW9uKG4pLCB0Yyk7XG4gICAgaWYgKCFzKSB7XG4gICAgICBkZWJ1Z0xvZyh2ZXJib3NlLCBgY2Fubm90IGdldCBzeW1ib2xgKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBUaGUgVFMtcHJvdmlkZWQgRlFOIHRlbGxzIHVzIHRoZSBmdWxsIGlkZW50aWZpZXIsIGFuZCB0aGUgb3JpZ2luIGZpbGVcbiAgICAvLyBpbiBzb21lIGNpcmN1bXN0YW5jZXMuXG4gICAgY29uc3QgZnFuID0gdGMuZ2V0RnVsbHlRdWFsaWZpZWROYW1lKHMpO1xuICAgIGRlYnVnTG9nKHZlcmJvc2UsIGBnb3QgRlFOICR7ZnFufWApO1xuXG4gICAgLy8gTmFtZS1iYXNlZCBjaGVja1xuICAgIGlmICghKGZxbi5lbmRzV2l0aCgnLicgKyB0aGlzLmJhbm5lZE5hbWUpIHx8IGZxbiA9PT0gdGhpcy5iYW5uZWROYW1lKSkge1xuICAgICAgZGVidWdMb2codmVyYm9zZSwgYEZRTiAke2Zxbn0gZG9lc24ndCBtYXRjaCBuYW1lICR7dGhpcy5iYW5uZWROYW1lfWApO1xuICAgICAgcmV0dXJuIGZhbHNlOyAgLy8gbm90IGEgdXNlIG9mIHRoZSBzeW1ib2xzIHdlIHdhbnRcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiBpdCdzIHBhcnQgb2YgYSBkZWNsYXJhdGlvbiBvciBpbXBvcnQuIFRoZSBjaGVjayBpcyBjaGVhcC4gSWZcbiAgICAvLyB3ZSdyZSBsb29raW5nIGZvciB0aGUgdXNlcyBvZiBhIHN5bWJvbCwgd2UgZG9uJ3QgYWxlcnQgb24gdGhlIGltcG9ydHMsIHRvXG4gICAgLy8gYXZvaWQgZmxvb2RpbmcgdXNlcnMgd2l0aCB3YXJuaW5ncyAoYXMgdGhlIGFjdHVhbCB1c2Ugd2lsbCBiZSBhbGVydGVkKVxuICAgIC8vIGFuZCBiYWQgZml4ZXMuXG4gICAgY29uc3QgcCA9IG4ucGFyZW50O1xuICAgIGlmIChwICYmIChpc0RlY2xhcmF0aW9uKHApIHx8IGlzUGFydE9mSW1wb3J0U3RhdGVtZW50KHApKSkge1xuICAgICAgZGVidWdMb2codmVyYm9zZSwgYFdlIGRvbid0IGZsYWcgc3ltYm9sIGRlY2xhcmF0aW9uc2ApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIE5vIGZpbGUgaW5mbyBpbiB0aGUgRlFOIG1lYW5zIGl0J3Mgbm90IGV4cGxpY2l0bHkgaW1wb3J0ZWQuXG4gICAgLy8gVGhhdCBtdXN0IHRoZXJlZm9yZSBiZSBhIGxvY2FsIHZhcmlhYmxlLCBvciBhbiBhbWJpZW50IHN5bWJvbFxuICAgIC8vIChhbmQgd2Ugb25seSBjYXJlIGFib3V0IGFtYmllbnRzIGhlcmUpLiBUaG9zZSBjb3VsZCBjb21lIGZyb21cbiAgICAvLyBlaXRoZXIgYSBkZWNsYXJlIHNvbWV3aGVyZSwgb3Igb25lIG9mIHRoZSBjb3JlIGxpYnJhcmllcyB0aGF0XG4gICAgLy8gYXJlIGxvYWRlZCBieSBkZWZhdWx0LlxuICAgIGlmICghZnFuLnN0YXJ0c1dpdGgoJ1wiJykpIHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gdHJhY2UgdGhpbmdzIGJhY2ssIHNvIGdldCBkZWNsYXJhdGlvbnMgb2YgdGhlIHN5bWJvbC5cbiAgICAgIGNvbnN0IGRlY2xhcmF0aW9ucyA9IHMuZ2V0RGVjbGFyYXRpb25zKCk7XG4gICAgICBpZiAoIWRlY2xhcmF0aW9ucykge1xuICAgICAgICBkZWJ1Z0xvZyh2ZXJib3NlLCBgU3ltYm9sIG5ldmVyIGRlY2xhcmVkP2ApO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoIWRlY2xhcmF0aW9ucy5zb21lKGlzQW1iaWVudERlY2xhcmF0aW9uKSAmJlxuICAgICAgICAgICFkZWNsYXJhdGlvbnMuc29tZShpc0luU3RvY2tMaWJyYXJpZXMpKSB7XG4gICAgICAgIGRlYnVnTG9nKFxuICAgICAgICAgICAgdmVyYm9zZSwgYFN5bWJvbCBuZWl0aGVyIGFtYmllbnQgbm9yIGZyb20gdGhlIHN0b2NrIGxpYnJhcmllc2ApO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZGVidWdMb2codmVyYm9zZSwgYGFsbCBjbGVhciwgcmVwb3J0IGZpbmRpbmdgKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG4vLyBUT0RPOiBFeHBvcnQgdGhlIG1hdGNoZWQgbm9kZSBraW5kcyBoZXJlLlxuLyoqXG4gKiBUaGlzIGNsYXNzIG1hdGNoZXMgYSBwcm9wZXJ0eSBhY2Nlc3Mgbm9kZSwgYmFzZWQgb24gYSBwcm9wZXJ0eSBob2xkZXIgdHlwZVxuICogKHRocm91Z2ggaXRzIG5hbWUpLCBpLmUuIGEgY2xhc3MsIGFuZCBhIHByb3BlcnR5IG5hbWUuXG4gKlxuICogVGhlIGxvZ2ljIGlzIHZvbHVudGFyaWx5IHNpbXBsZTogaWYgYSBtYXRjaGVyIGZvciBgYS5iYCB0ZXN0cyBhIGB4LnlgIG5vZGUsXG4gKiBpdCB3aWxsIHJldHVybiB0cnVlIGlmOlxuICogLSBgeGAgaXMgb2YgdHlwZSBgYWAgZWl0aGVyIGRpcmVjdGx5IChuYW1lLWJhc2VkKSBvciB0aHJvdWdoIGluaGVyaXRhbmNlXG4gKiAgIChkaXR0byksXG4gKiAtIGFuZCwgdGV4dHVhbGx5LCBgeWAgPT09IGBiYC5cbiAqXG4gKiBOb3RlIHRoYXQgdGhlIGxvZ2ljIGlzIGRpZmZlcmVudCBmcm9tIFRTJ3MgdHlwZSBzeXN0ZW06IHRoaXMgbWF0Y2hlciBkb2Vzbid0XG4gKiBoYXZlIGFueSBrbm93bGVkZ2Ugb2Ygc3RydWN0dXJhbCB0eXBpbmcuXG4gKi9cbmV4cG9ydCBjbGFzcyBQcm9wZXJ0eU1hdGNoZXIge1xuICBzdGF0aWMgZnJvbVNwZWMoc3BlYzogc3RyaW5nKTogUHJvcGVydHlNYXRjaGVyIHtcbiAgICBpZiAoc3BlYy5pbmRleE9mKCcucHJvdG90eXBlLicpID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBCQU5ORURfUFJPUEVSVFkgZXhwZWN0cyBhIC5wcm90b3R5cGUgaW4geW91ciBxdWVyeS5gKTtcbiAgICB9XG4gICAgY29uc3QgcmVxdWVzdFBhcnNlciA9IC9eKFtcXHdcXGRfLi1dKylcXC5wcm90b3R5cGVcXC4oW1xcd1xcZF8uLV0rKSQvO1xuICAgIGNvbnN0IG1hdGNoZXMgPSByZXF1ZXN0UGFyc2VyLmV4ZWMoc3BlYyk7XG4gICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCB1bmRlcnN0YW5kIHRoZSBCYW5uZWRQcm9wZXJ0eSBzcGVjJyArIHNwZWMpO1xuICAgIH1cbiAgICBjb25zdCBbYmFubmVkVHlwZSwgYmFubmVkUHJvcGVydHldID0gbWF0Y2hlcy5zbGljZSgxKTtcbiAgICByZXR1cm4gbmV3IFByb3BlcnR5TWF0Y2hlcihiYW5uZWRUeXBlLCBiYW5uZWRQcm9wZXJ0eSk7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihyZWFkb25seSBiYW5uZWRUeXBlOiBzdHJpbmcsIHJlYWRvbmx5IGJhbm5lZFByb3BlcnR5OiBzdHJpbmcpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSBuIFRoZSBQcm9wZXJ0eUFjY2Vzc0V4cHJlc3Npb24gd2UncmUgbG9va2luZyBhdC5cbiAgICovXG4gIG1hdGNoZXMoXG4gICAgICBuOiB0cy5Qcm9wZXJ0eUFjY2Vzc0V4cHJlc3Npb24sIHRjOiB0cy5UeXBlQ2hlY2tlciwgdmVyYm9zZT86IGJvb2xlYW4pIHtcbiAgICByZXR1cm4gbi5uYW1lLnRleHQgPT09IHRoaXMuYmFubmVkUHJvcGVydHkgJiZcbiAgICAgICAgdGhpcy50eXBlTWF0Y2hlcyh0Yy5nZXRUeXBlQXRMb2NhdGlvbihuLmV4cHJlc3Npb24pKTtcbiAgfVxuXG4gIHByaXZhdGUgZXhhY3RUeXBlTWF0Y2hlcyhpbnNwZWN0ZWRUeXBlOiB0cy5UeXBlKTogYm9vbGVhbiB7XG4gICAgY29uc3QgdHlwZVN5bWJvbCA9IGluc3BlY3RlZFR5cGUuZ2V0U3ltYm9sKCkgfHwgZmFsc2U7XG4gICAgcmV0dXJuIHR5cGVTeW1ib2wgJiYgdHlwZVN5bWJvbC5nZXROYW1lKCkgPT09IHRoaXMuYmFubmVkVHlwZTtcbiAgfVxuXG4gIC8vIFRPRE86IEFjY291bnQgZm9yIHVua25vd24gdHlwZXMvICc/JywgYW5kICdsb29zZSB0eXBlIG1hdGNoZXMnLCBpLmUuIGlmIHRoZVxuICAvLyBhY3R1YWwgdHlwZSBpcyBhIHN1cGVydHlwZSBvZiB0aGUgcHJvaGliaXRlZCB0eXBlLlxuICBwcml2YXRlIHR5cGVNYXRjaGVzKGluc3BlY3RlZFR5cGU6IHRzLlR5cGUpOiBib29sZWFuIHtcbiAgICBpZiAodGhpcy5leGFjdFR5cGVNYXRjaGVzKGluc3BlY3RlZFR5cGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgYmFzZVR5cGVzID0gaW5zcGVjdGVkVHlwZS5nZXRCYXNlVHlwZXMoKSB8fCBbXTtcbiAgICByZXR1cm4gYmFzZVR5cGVzLnNvbWUoYmFzZSA9PiB0aGlzLmV4YWN0VHlwZU1hdGNoZXMoYmFzZSkpO1xuICB9XG59XG4iXX0=