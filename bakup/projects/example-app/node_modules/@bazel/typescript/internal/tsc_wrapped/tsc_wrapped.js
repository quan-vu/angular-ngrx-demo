(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "fs", "path", "typescript", "../tsetse/runner", "./cache", "./compiler_host", "./diagnostics", "./manifest", "./perf_trace", "./strict_deps", "./tsconfig", "./worker"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const fs = require("fs");
    const path = require("path");
    const ts = require("typescript");
    const runner_1 = require("../tsetse/runner");
    const cache_1 = require("./cache");
    const compiler_host_1 = require("./compiler_host");
    const bazelDiagnostics = require("./diagnostics");
    const manifest_1 = require("./manifest");
    const perfTrace = require("./perf_trace");
    const strict_deps_1 = require("./strict_deps");
    const tsconfig_1 = require("./tsconfig");
    const worker_1 = require("./worker");
    // Equivalent of running node with --expose-gc
    // but easier to write tooling since we don't need to inject that arg to
    // nodejs_binary
    if (typeof global.gc !== 'function') {
        require('v8').setFlagsFromString('--expose_gc');
        global.gc = require('vm').runInNewContext('gc');
    }
    /**
     * Top-level entry point for tsc_wrapped.
     */
    function main(args) {
        if (worker_1.runAsWorker(args)) {
            worker_1.log('Starting TypeScript compiler persistent worker...');
            worker_1.runWorkerLoop(runOneBuild);
            // Note: intentionally don't process.exit() here, because runWorkerLoop
            // is waiting for async callbacks from node.
        }
        else {
            worker_1.debug('Running a single build...');
            if (args.length === 0)
                throw new Error('Not enough arguments');
            if (!runOneBuild(args)) {
                return 1;
            }
        }
        return 0;
    }
    exports.main = main;
    /** The one ProgramAndFileCache instance used in this process. */
    const cache = new cache_1.ProgramAndFileCache(worker_1.debug);
    function isCompilationTarget(bazelOpts, sf) {
        if (bazelOpts.isJsTranspilation && bazelOpts.transpiledJsInputDirectory) {
            // transpiledJsInputDirectory is a relative logical path, so we cannot
            // compare it to the resolved, absolute path of sf here.
            // compilationTargetSrc is resolved, so use that for the comparison.
            return sf.fileName.startsWith(bazelOpts.compilationTargetSrc[0]);
        }
        return (bazelOpts.compilationTargetSrc.indexOf(sf.fileName) !== -1);
    }
    /**
     * Gather diagnostics from TypeScript's type-checker as well as other plugins we
     * install such as strict dependency checking.
     */
    function gatherDiagnostics(options, bazelOpts, program, disabledTsetseRules, angularPlugin) {
        // Install extra diagnostic plugins
        if (!bazelOpts.disableStrictDeps) {
            program = strict_deps_1.PLUGIN.wrap(program, Object.assign({}, bazelOpts, { rootDir: options.rootDir }));
        }
        if (!bazelOpts.isJsTranspilation) {
            let selectedTsetsePlugin = runner_1.PLUGIN;
            program = selectedTsetsePlugin.wrap(program, disabledTsetseRules);
        }
        if (angularPlugin) {
            program = angularPlugin.wrap(program);
        }
        const diagnostics = [];
        perfTrace.wrap('type checking', () => {
            // These checks mirror ts.getPreEmitDiagnostics, with the important
            // exception of avoiding b/30708240, which is that if you call
            // program.getDeclarationDiagnostics() it somehow corrupts the emit.
            perfTrace.wrap(`global diagnostics`, () => {
                diagnostics.push(...program.getOptionsDiagnostics());
                diagnostics.push(...program.getGlobalDiagnostics());
            });
            let sourceFilesToCheck;
            if (bazelOpts.typeCheckDependencies) {
                sourceFilesToCheck = program.getSourceFiles();
            }
            else {
                sourceFilesToCheck = program.getSourceFiles().filter(f => isCompilationTarget(bazelOpts, f));
            }
            for (const sf of sourceFilesToCheck) {
                perfTrace.wrap(`check ${sf.fileName}`, () => {
                    diagnostics.push(...program.getSyntacticDiagnostics(sf));
                    diagnostics.push(...program.getSemanticDiagnostics(sf));
                });
                perfTrace.snapshotMemoryUsage();
            }
        });
        return diagnostics;
    }
    exports.gatherDiagnostics = gatherDiagnostics;
    /**
     * expandSourcesFromDirectories finds any directories under filePath and expands
     * them to their .js or .ts contents.
     */
    function expandSourcesFromDirectories(fileList, filePath) {
        if (!fs.statSync(filePath).isDirectory()) {
            if (filePath.endsWith('.ts') || filePath.endsWith('.tsx') ||
                filePath.endsWith('.js')) {
                fileList.push(filePath);
            }
            return;
        }
        const entries = fs.readdirSync(filePath);
        for (const entry of entries) {
            expandSourcesFromDirectories(fileList, path.join(filePath, entry));
        }
    }
    /**
     * Runs a single build, returning false on failure.  This is potentially called
     * multiple times (once per bazel request) when running as a bazel worker.
     * Any encountered errors are written to stderr.
     */
    function runOneBuild(args, inputs) {
        if (args.length !== 1) {
            console.error('Expected one argument: path to tsconfig.json');
            return false;
        }
        perfTrace.snapshotMemoryUsage();
        // Strip leading at-signs, used in build_defs.bzl to indicate a params file
        const tsconfigFile = args[0].replace(/^@+/, '');
        const [parsed, errors, { target }] = tsconfig_1.parseTsconfig(tsconfigFile);
        if (errors) {
            console.error(bazelDiagnostics.format(target, errors));
            return false;
        }
        if (!parsed) {
            throw new Error('Impossible state: if parseTsconfig returns no errors, then parsed should be non-null');
        }
        const { options, bazelOpts, files, disabledTsetseRules, angularCompilerOptions } = parsed;
        const sourceFiles = [];
        for (let i = 0; i < files.length; i++) {
            const filePath = files[i];
            expandSourcesFromDirectories(sourceFiles, filePath);
        }
        if (bazelOpts.maxCacheSizeMb !== undefined) {
            const maxCacheSizeBytes = bazelOpts.maxCacheSizeMb * (1 << 20);
            cache.setMaxCacheSize(maxCacheSizeBytes);
        }
        else {
            cache.resetMaxCacheSize();
        }
        let fileLoader;
        if (inputs) {
            fileLoader = new cache_1.CachedFileLoader(cache);
            // Resolve the inputs to absolute paths to match TypeScript internals
            const resolvedInputs = new Map();
            for (const key of Object.keys(inputs)) {
                resolvedInputs.set(tsconfig_1.resolveNormalizedPath(key), inputs[key]);
            }
            cache.updateCache(resolvedInputs);
        }
        else {
            fileLoader = new cache_1.UncachedFileLoader();
        }
        const perfTracePath = bazelOpts.perfTracePath;
        if (!perfTracePath) {
            return runFromOptions(fileLoader, options, bazelOpts, sourceFiles, disabledTsetseRules, angularCompilerOptions);
        }
        worker_1.log('Writing trace to', perfTracePath);
        const success = perfTrace.wrap('runOneBuild', () => runFromOptions(fileLoader, options, bazelOpts, sourceFiles, disabledTsetseRules, angularCompilerOptions));
        if (!success)
            return false;
        // Force a garbage collection pass.  This keeps our memory usage
        // consistent across multiple compilations, and allows the file
        // cache to use the current memory usage as a guideline for expiring
        // data.  Note: this is intentionally not within runFromOptions(), as
        // we want to gc only after all its locals have gone out of scope.
        global.gc();
        perfTrace.snapshotMemoryUsage();
        perfTrace.write(perfTracePath);
        return true;
    }
    // We only allow our own code to use the expected_diagnostics attribute
    const expectDiagnosticsWhitelist = [];
    function runFromOptions(fileLoader, options, bazelOpts, files, disabledTsetseRules, angularCompilerOptions) {
        perfTrace.snapshotMemoryUsage();
        cache.resetStats();
        cache.traceStats();
        const compilerHostDelegate = ts.createCompilerHost({ target: ts.ScriptTarget.ES5 });
        const moduleResolver = bazelOpts.isJsTranspilation ?
            makeJsModuleResolver(bazelOpts.workspaceName) :
            ts.resolveModuleName;
        const tsickleCompilerHost = new compiler_host_1.CompilerHost(files, options, bazelOpts, compilerHostDelegate, fileLoader, moduleResolver);
        let compilerHost = tsickleCompilerHost;
        let angularPlugin;
        if (bazelOpts.compileAngularTemplates) {
            try {
                const ngOptions = angularCompilerOptions || {};
                // Add the rootDir setting to the options passed to NgTscPlugin.
                // Required so that synthetic files added to the rootFiles in the program
                // can be given absolute paths, just as we do in tsconfig.ts, matching
                // the behavior in TypeScript's tsconfig parsing logic.
                ngOptions['rootDir'] = options.rootDir;
                // Dynamically load the Angular compiler installed as a peerDep
                const ngtsc = require('@angular/compiler-cli');
                angularPlugin = new ngtsc.NgTscPlugin(ngOptions);
            }
            catch (e) {
                console.error(e);
                throw new Error('when using `ts_library(compile_angular_templates=True)`, ' +
                    'you must install @angular/compiler-cli');
            }
            // Wrap host only needed until after Ivy cleanup
            // TODO(alexeagle): remove after ngsummary and ngfactory files eliminated
            compilerHost = angularPlugin.wrapHost(files, compilerHost);
        }
        const oldProgram = cache.getProgram(bazelOpts.target);
        const program = perfTrace.wrap('createProgram', () => ts.createProgram(compilerHost.inputFiles, options, compilerHost, oldProgram));
        cache.putProgram(bazelOpts.target, program);
        if (!bazelOpts.isJsTranspilation) {
            // If there are any TypeScript type errors abort now, so the error
            // messages refer to the original source.  After any subsequent passes
            // (decorator downleveling or tsickle) we do not type check.
            let diagnostics = gatherDiagnostics(options, bazelOpts, program, disabledTsetseRules, angularPlugin);
            if (!expectDiagnosticsWhitelist.length ||
                expectDiagnosticsWhitelist.some(p => bazelOpts.target.startsWith(p))) {
                diagnostics = bazelDiagnostics.filterExpected(bazelOpts, diagnostics, bazelDiagnostics.uglyFormat);
            }
            else if (bazelOpts.expectedDiagnostics.length > 0) {
                console.error(`Only targets under ${expectDiagnosticsWhitelist.join(', ')} can use ` +
                    'expected_diagnostics, but got', bazelOpts.target);
            }
            if (diagnostics.length > 0) {
                console.error(bazelDiagnostics.format(bazelOpts.target, diagnostics));
                worker_1.debug('compilation failed at', new Error().stack);
                return false;
            }
        }
        const compilationTargets = program.getSourceFiles().filter(fileName => isCompilationTarget(bazelOpts, fileName));
        let diagnostics = [];
        let useTsickleEmit = bazelOpts.tsickle;
        let transforms = {
            before: [],
            after: [],
            afterDeclarations: [],
        };
        if (angularPlugin) {
            transforms = angularPlugin.createTransformers(compilerHost);
        }
        if (useTsickleEmit) {
            diagnostics = emitWithTsickle(program, tsickleCompilerHost, compilationTargets, options, bazelOpts, transforms);
        }
        else {
            diagnostics = emitWithTypescript(program, compilationTargets, transforms);
        }
        if (diagnostics.length > 0) {
            console.error(bazelDiagnostics.format(bazelOpts.target, diagnostics));
            worker_1.debug('compilation failed at', new Error().stack);
            return false;
        }
        cache.printStats();
        return true;
    }
    function emitWithTypescript(program, compilationTargets, transforms) {
        const diagnostics = [];
        for (const sf of compilationTargets) {
            const result = program.emit(sf, /*writeFile*/ undefined, 
            /*cancellationToken*/ undefined, /*emitOnlyDtsFiles*/ undefined, transforms);
            diagnostics.push(...result.diagnostics);
        }
        return diagnostics;
    }
    /**
     * Runs the emit pipeline with Tsickle transformations - goog.module rewriting
     * and Closure types emitted included.
     * Exported to be used by the internal global refactoring tools.
     * TODO(radokirov): investigate using runWithOptions and making this private
     * again, if we can make compilerHosts match.
     */
    function emitWithTsickle(program, compilerHost, compilationTargets, options, bazelOpts, transforms) {
        const emitResults = [];
        const diagnostics = [];
        // The 'tsickle' import above is only used in type positions, so it won't
        // result in a runtime dependency on tsickle.
        // If the user requests the tsickle emit, then we dynamically require it
        // here for use at runtime.
        let optTsickle;
        try {
            // tslint:disable-next-line:no-require-imports
            optTsickle = require('tsickle');
        }
        catch (e) {
            if (e.code !== 'MODULE_NOT_FOUND') {
                throw e;
            }
            throw new Error('When setting bazelOpts { tsickle: true }, ' +
                'you must also add a devDependency on the tsickle npm package');
        }
        perfTrace.wrap('emit', () => {
            for (const sf of compilationTargets) {
                perfTrace.wrap(`emit ${sf.fileName}`, () => {
                    emitResults.push(optTsickle.emitWithTsickle(program, compilerHost, compilerHost, options, sf, 
                    /*writeFile*/ undefined, 
                    /*cancellationToken*/ undefined, /*emitOnlyDtsFiles*/ undefined, {
                        beforeTs: transforms.before,
                        afterTs: transforms.after,
                        afterDeclarations: transforms.afterDeclarations,
                    }));
                });
            }
        });
        const emitResult = optTsickle.mergeEmitResults(emitResults);
        diagnostics.push(...emitResult.diagnostics);
        // If tsickle reported diagnostics, don't produce externs or manifest outputs.
        if (diagnostics.length > 0) {
            return diagnostics;
        }
        let externs = '/** @externs */\n' +
            '// generating externs was disabled using generate_externs=False\n';
        if (bazelOpts.tsickleGenerateExterns) {
            externs =
                optTsickle.getGeneratedExterns(emitResult.externs, options.rootDir);
        }
        if (bazelOpts.tsickleExternsPath) {
            // Note: when tsickleExternsPath is provided, we always write a file as a
            // marker that compilation succeeded, even if it's empty (just containing an
            // @externs).
            fs.writeFileSync(bazelOpts.tsickleExternsPath, externs);
            // When generating externs, generate an externs file for each of the input
            // .d.ts files.
            if (bazelOpts.tsickleGenerateExterns &&
                compilerHost.provideExternalModuleDtsNamespace) {
                for (const extern of compilationTargets) {
                    if (!extern.isDeclarationFile)
                        continue;
                    const outputBaseDir = options.outDir;
                    const relativeOutputPath = compilerHost.relativeOutputPath(extern.fileName);
                    mkdirp(outputBaseDir, path.dirname(relativeOutputPath));
                    const outputPath = path.join(outputBaseDir, relativeOutputPath);
                    const moduleName = compilerHost.pathToModuleName('', extern.fileName);
                    fs.writeFileSync(outputPath, `goog.module('${moduleName}');\n` +
                        `// Export an empty object of unknown type to allow imports.\n` +
                        `// TODO: use typeof once available\n` +
                        `exports = /** @type {?} */ ({});\n`);
                }
            }
        }
        if (bazelOpts.manifest) {
            perfTrace.wrap('manifest', () => {
                const manifest = manifest_1.constructManifest(emitResult.modulesManifest, compilerHost);
                fs.writeFileSync(bazelOpts.manifest, manifest);
            });
        }
        return diagnostics;
    }
    exports.emitWithTsickle = emitWithTsickle;
    /**
     * Creates directories subdir (a slash separated relative path) starting from
     * base.
     */
    function mkdirp(base, subdir) {
        const steps = subdir.split(path.sep);
        let current = base;
        for (let i = 0; i < steps.length; i++) {
            current = path.join(current, steps[i]);
            if (!fs.existsSync(current))
                fs.mkdirSync(current);
        }
    }
    /**
     * Resolve module filenames for JS modules.
     *
     * JS module resolution needs to be different because when transpiling JS we
     * do not pass in any dependencies, so the TS module resolver will not resolve
     * any files.
     *
     * Fortunately, JS module resolution is very simple. The imported module name
     * must either a relative path, or the workspace root (i.e. 'google3'),
     * so we can perform module resolution entirely based on file names, without
     * looking at the filesystem.
     */
    function makeJsModuleResolver(workspaceName) {
        // The literal '/' here is cross-platform safe because it's matching on
        // import specifiers, not file names.
        const workspaceModuleSpecifierPrefix = `${workspaceName}/`;
        const workspaceDir = `${path.sep}${workspaceName}${path.sep}`;
        function jsModuleResolver(moduleName, containingFile, compilerOptions, host) {
            let resolvedFileName;
            if (containingFile === '') {
                // In tsickle we resolve the filename against '' to get the goog module
                // name of a sourcefile.
                resolvedFileName = moduleName;
            }
            else if (moduleName.startsWith(workspaceModuleSpecifierPrefix)) {
                // Given a workspace name of 'foo', we want to resolve import specifiers
                // like: 'foo/project/file.js' to the absolute filesystem path of
                // project/file.js within the workspace.
                const workspaceDirLocation = containingFile.indexOf(workspaceDir);
                if (workspaceDirLocation < 0) {
                    return { resolvedModule: undefined };
                }
                const absolutePathToWorkspaceDir = containingFile.slice(0, workspaceDirLocation);
                resolvedFileName = path.join(absolutePathToWorkspaceDir, moduleName);
            }
            else {
                if (!moduleName.startsWith('./') && !moduleName.startsWith('../')) {
                    throw new Error(`Unsupported module import specifier: ${JSON.stringify(moduleName)}.\n` +
                        `JS module imports must either be relative paths ` +
                        `(beginning with '.' or '..'), ` +
                        `or they must begin with '${workspaceName}/'.`);
                }
                resolvedFileName = path.join(path.dirname(containingFile), moduleName);
            }
            return {
                resolvedModule: {
                    resolvedFileName,
                    extension: ts.Extension.Js,
                    // These two fields are cargo culted from what ts.resolveModuleName
                    // seems to return.
                    packageId: undefined,
                    isExternalLibraryImport: false,
                }
            };
        }
        return jsModuleResolver;
    }
    if (require.main === module) {
        // Do not call process.exit(), as that terminates the binary before
        // completing pending operations, such as writing to stdout or emitting the
        // v8 performance log. Rather, set the exit code and fall off the main
        // thread, which will cause node to terminate cleanly.
        process.exitCode = main(process.argv.slice(2));
    }
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHNjX3dyYXBwZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9leHRlcm5hbC9idWlsZF9iYXplbF9ydWxlc190eXBlc2NyaXB0L2ludGVybmFsL3RzY193cmFwcGVkL3RzY193cmFwcGVkLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0lBQUEseUJBQXlCO0lBQ3pCLDZCQUE2QjtJQUU3QixpQ0FBaUM7SUFFakMsNkNBQWtFO0lBRWxFLG1DQUE4RjtJQUM5RixtREFBNkM7SUFDN0Msa0RBQWtEO0lBQ2xELHlDQUE2QztJQUM3QywwQ0FBMEM7SUFFMUMsK0NBQXlEO0lBQ3pELHlDQUE4RTtJQUM5RSxxQ0FBZ0U7SUFFaEUsOENBQThDO0lBQzlDLHdFQUF3RTtJQUN4RSxnQkFBZ0I7SUFDaEIsSUFBSSxPQUFPLE1BQU0sQ0FBQyxFQUFFLEtBQUssVUFBVSxFQUFFO1FBQ25DLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxrQkFBa0IsQ0FBQyxhQUFhLENBQUMsQ0FBQztRQUNoRCxNQUFNLENBQUMsRUFBRSxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLENBQUM7S0FDakQ7SUFFRDs7T0FFRztJQUNILFNBQWdCLElBQUksQ0FBQyxJQUFjO1FBQ2pDLElBQUksb0JBQVcsQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUNyQixZQUFHLENBQUMsbURBQW1ELENBQUMsQ0FBQztZQUN6RCxzQkFBYSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1lBQzNCLHVFQUF1RTtZQUN2RSw0Q0FBNEM7U0FDN0M7YUFBTTtZQUNMLGNBQUssQ0FBQywyQkFBMkIsQ0FBQyxDQUFDO1lBQ25DLElBQUksSUFBSSxDQUFDLE1BQU0sS0FBSyxDQUFDO2dCQUFFLE1BQU0sSUFBSSxLQUFLLENBQUMsc0JBQXNCLENBQUMsQ0FBQztZQUMvRCxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxF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RTtvQkFDMUIsbUVBQW1FO29CQUNuRSxtQkFBbUI7b0JBQ25CLFNBQVMsRUFBRSxTQUFTO29CQUNwQix1QkFBdUIsRUFBRSxLQUFLO2lCQUMvQjthQUNGLENBQUM7UUFDSixDQUFDO1FBRUQsT0FBTyxnQkFBZ0IsQ0FBQztJQUMxQixDQUFDO0lBR0QsSUFBSSxPQUFPLENBQUMsSUFBSSxLQUFLLE1BQU0sRUFBRTtRQUMzQixtRUFBbUU7UUFDbkUsMkVBQTJFO1FBQzNFLHNFQUFzRTtRQUN0RSxzREFBc0Q7UUFDdEQsT0FBTyxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztLQUNoRCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgKiBhcyB0c2lja2xlIGZyb20gJ3RzaWNrbGUnO1xuaW1wb3J0ICogYXMgdHMgZnJvbSAndHlwZXNjcmlwdCc7XG5cbmltcG9ydCB7UExVR0lOIGFzIGJhemVsQ29uZm9ybWFuY2VQbHVnaW59IGZyb20gJy4uL3RzZXRzZS9ydW5uZXInO1xuXG5pbXBvcnQge0NhY2hlZEZpbGVMb2FkZXIsIEZpbGVMb2FkZXIsIFByb2dyYW1BbmRGaWxlQ2FjaGUsIFVuY2FjaGVkRmlsZUxvYWRlcn0gZnJvbSAnLi9jYWNoZSc7XG5pbXBvcnQge0NvbXBpbGVySG9zdH0gZnJvbSAnLi9jb21waWxlcl9ob3N0JztcbmltcG9ydCAqIGFzIGJhemVsRGlhZ25vc3RpY3MgZnJvbSAnLi9kaWFnbm9zdGljcyc7XG5pbXBvcnQge2NvbnN0cnVjdE1hbmlmZXN0fSBmcm9tICcuL21hbmlmZXN0JztcbmltcG9ydCAqIGFzIHBlcmZUcmFjZSBmcm9tICcuL3BlcmZfdHJhY2UnO1xuaW1wb3J0IHtQbHVnaW5Db21waWxlckhvc3QsIFRzY1BsdWdpbn0gZnJvbSAnLi9wbHVnaW5fYXBpJztcbmltcG9ydCB7UExVR0lOIGFzIHN0cmljdERlcHNQbHVnaW59IGZyb20gJy4vc3RyaWN0X2RlcHMnO1xuaW1wb3J0IHtCYXplbE9wdGlvbnMsIHBhcnNlVHNjb25maWcsIHJlc29sdmVOb3JtYWxpemVkUGF0aH0gZnJvbSAnLi90c2NvbmZpZyc7XG5pbXBvcnQge2RlYnVnLCBsb2csIHJ1bkFzV29ya2VyLCBydW5Xb3JrZXJMb29wfSBmcm9tICcuL3dvcmtlcic7XG5cbi8vIEVxdWl2YWxlbnQgb2YgcnVubmluZyBub2RlIHdpdGggLS1leHBvc2UtZ2Ncbi8vIGJ1dCBlYXNpZXIgdG8gd3JpdGUgdG9vbGluZyBzaW5jZSB3ZSBkb24ndCBuZWVkIHRvIGluamVjdCB0aGF0IGFyZyB0b1xuLy8gbm9kZWpzX2JpbmFyeVxuaWYgKHR5cGVvZiBnbG9iYWwuZ2MgIT09ICdmdW5jdGlvbicpIHtcbiAgcmVxdWlyZSgndjgnKS5zZXRGbGFnc0Zyb21TdHJpbmcoJy0tZXhwb3NlX2djJyk7XG4gIGdsb2JhbC5nYyA9IHJlcXVpcmUoJ3ZtJykucnVuSW5OZXdDb250ZXh0KCdnYycpO1xufVxuXG4vKipcbiAqIFRvcC1sZXZlbCBlbnRyeSBwb2ludCBmb3IgdHNjX3dyYXBwZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWluKGFyZ3M6IHN0cmluZ1tdKSB7XG4gIGlmIChydW5Bc1dvcmtlcihhcmdzKSkge1xuICAgIGxvZygnU3RhcnRpbmcgVHlwZVNjcmlwdCBjb21waWxlciBwZXJzaXN0ZW50IHdvcmtlci4uLicpO1xuICAgIHJ1bldvcmtlckxvb3AocnVuT25lQnVpbGQpO1xuICAgIC8vIE5vdGU6IGludGVudGlvbmFsbHkgZG9uJ3QgcHJvY2Vzcy5leGl0KCkgaGVyZSwgYmVjYXVzZSBydW5Xb3JrZXJMb29wXG4gICAgLy8gaXMgd2FpdGluZyBmb3IgYXN5bmMgY2FsbGJhY2tzIGZyb20gbm9kZS5cbiAgfSBlbHNlIHtcbiAgICBkZWJ1ZygnUnVubmluZyBhIHNpbmdsZSBidWlsZC4uLicpO1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkgdGhyb3cgbmV3IEVycm9yKCdOb3QgZW5vdWdoIGFyZ3VtZW50cycpO1xuICAgIGlmICghcnVuT25lQnVpbGQoYXJncykpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLyoqIFRoZSBvbmUgUHJvZ3JhbUFuZEZpbGVDYWNoZSBpbnN0YW5jZSB1c2VkIGluIHRoaXMgcHJvY2Vzcy4gKi9cbmNvbnN0IGNhY2hlID0gbmV3IFByb2dyYW1BbmRGaWxlQ2FjaGUoZGVidWcpO1xuXG5mdW5jdGlvbiBpc0NvbXBpbGF0aW9uVGFyZ2V0KFxuICAgIGJhemVsT3B0czogQmF6ZWxPcHRpb25zLCBzZjogdHMuU291cmNlRmlsZSk6IGJvb2xlYW4ge1xuICBpZiAoYmF6ZWxPcHRzLmlzSnNUcmFuc3BpbGF0aW9uICYmIGJhemVsT3B0cy50cmFuc3BpbGVkSnNJbnB1dERpcmVjdG9yeSkge1xuICAgIC8vIHRyYW5zcGlsZWRKc0lucHV0RGlyZWN0b3J5IGlzIGEgcmVsYXRpdmUgbG9naWNhbCBwYXRoLCBzbyB3ZSBjYW5ub3RcbiAgICAvLyBjb21wYXJlIGl0IHRvIHRoZSByZXNvbHZlZCwgYWJzb2x1dGUgcGF0aCBvZiBzZiBoZXJlLlxuICAgIC8vIGNvbXBpbGF0aW9uVGFyZ2V0U3JjIGlzIHJlc29sdmVkLCBzbyB1c2UgdGhhdCBmb3IgdGhlIGNvbXBhcmlzb24uXG4gICAgcmV0dXJuIHNmLmZpbGVOYW1lLnN0YXJ0c1dpdGgoYmF6ZWxPcHRzLmNvbXBpbGF0aW9uVGFyZ2V0U3JjWzBdKTtcbiAgfVxuICByZXR1cm4gKGJhemVsT3B0cy5jb21waWxhdGlvblRhcmdldFNyYy5pbmRleE9mKHNmLmZpbGVOYW1lKSAhPT0gLTEpO1xufVxuXG4vKipcbiAqIEdhdGhlciBkaWFnbm9zdGljcyBmcm9tIFR5cGVTY3JpcHQncyB0eXBlLWNoZWNrZXIgYXMgd2VsbCBhcyBvdGhlciBwbHVnaW5zIHdlXG4gKiBpbnN0YWxsIHN1Y2ggYXMgc3RyaWN0IGRlcGVuZGVuY3kgY2hlY2tpbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnYXRoZXJEaWFnbm9zdGljcyhcbiAgICBvcHRpb25zOiB0cy5Db21waWxlck9wdGlvbnMsIGJhemVsT3B0czogQmF6ZWxPcHRpb25zLCBwcm9ncmFtOiB0cy5Qcm9ncmFtLFxuICAgIGRpc2FibGVkVHNldHNlUnVsZXM6IHN0cmluZ1tdLCBhbmd1bGFyUGx1Z2luPzogVHNjUGx1Z2luKTogdHMuRGlhZ25vc3RpY1tdIHtcbiAgLy8gSW5zdGFsbCBleHRyYSBkaWFnbm9zdGljIHBsdWdpbnNcbiAgaWYgKCFiYXplbE9wdHMuZGlzYWJsZVN0cmljdERlcHMpIHtcbiAgICBwcm9ncmFtID0gc3RyaWN0RGVwc1BsdWdpbi53cmFwKHByb2dyYW0sIHtcbiAgICAgIC4uLmJhemVsT3B0cyxcbiAgICAgIHJvb3REaXI6IG9wdGlvbnMucm9vdERpcixcbiAgICB9KTtcbiAgfVxuICBpZiAoIWJhemVsT3B0cy5pc0pzVHJhbnNwaWxhdGlvbikge1xuICAgIGxldCBzZWxlY3RlZFRzZXRzZVBsdWdpbiA9IGJhemVsQ29uZm9ybWFuY2VQbHVnaW47XG4gICAgcHJvZ3JhbSA9IHNlbGVjdGVkVHNldHNlUGx1Z2luLndyYXAocHJvZ3JhbSwgZGlzYWJsZWRUc2V0c2VSdWxlcyk7XG4gIH1cbiAgaWYgKGFuZ3VsYXJQbHVnaW4pIHtcbiAgICBwcm9ncmFtID0gYW5ndWxhclBsdWdpbi53cmFwKHByb2dyYW0pO1xuICB9XG5cbiAgY29uc3QgZGlhZ25vc3RpY3M6IHRzLkRpYWdub3N0aWNbXSA9IFtdO1xuICBwZXJmVHJhY2Uud3JhcCgndHlwZSBjaGVja2luZycsICgpID0+IHtcbiAgICAvLyBUaGVzZSBjaGVja3MgbWlycm9yIHRzLmdldFByZUVtaXREaWFnbm9zdGljcywgd2l0aCB0aGUgaW1wb3J0YW50XG4gICAgLy8gZXhjZXB0aW9uIG9mIGF2b2lkaW5nIGIvMzA3MDgyNDAsIHdoaWNoIGlzIHRoYXQgaWYgeW91IGNhbGxcbiAgICAvLyBwcm9ncmFtLmdldERlY2xhcmF0aW9uRGlhZ25vc3RpY3MoKSBpdCBzb21laG93IGNvcnJ1cHRzIHRoZSBlbWl0LlxuICAgIHBlcmZUcmFjZS53cmFwKGBnbG9iYWwgZGlhZ25vc3RpY3NgLCAoKSA9PiB7XG4gICAgICBkaWFnbm9zdGljcy5wdXNoKC4uLnByb2dyYW0uZ2V0T3B0aW9uc0RpYWdub3N0aWNzKCkpO1xuICAgICAgZGlhZ25vc3RpY3MucHVzaCguLi5wcm9ncmFtLmdldEdsb2JhbERpYWdub3N0aWNzKCkpO1xuICAgIH0pO1xuICAgIGxldCBzb3VyY2VGaWxlc1RvQ2hlY2s6IFJlYWRvbmx5QXJyYXk8dHMuU291cmNlRmlsZT47XG4gICAgaWYgKGJhemVsT3B0cy50eXBlQ2hlY2tEZXBlbmRlbmNpZXMpIHtcbiAgICAgIHNvdXJjZUZpbGVzVG9DaGVjayA9IHByb2dyYW0uZ2V0U291cmNlRmlsZXMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc291cmNlRmlsZXNUb0NoZWNrID0gcHJvZ3JhbS5nZXRTb3VyY2VGaWxlcygpLmZpbHRlcihcbiAgICAgICAgICBmID0+IGlzQ29tcGlsYXRpb25UYXJnZXQoYmF6ZWxPcHRzLCBmKSk7XG4gICAgfVxuICAgIGZvciAoY29uc3Qgc2Ygb2Ygc291cmNlRmlsZXNUb0NoZWNrKSB7XG4gICAgICBwZXJmVHJhY2Uud3JhcChgY2hlY2sgJHtzZi5maWxlTmFtZX1gLCAoKSA9PiB7XG4gICAgICAgIGRpYWdub3N0aWNzLnB1c2goLi4ucHJvZ3JhbS5nZXRTeW50YWN0aWNEaWFnbm9zdGljcyhzZikpO1xuICAgICAgICBkaWFnbm9zdGljcy5wdXNoKC4uLnByb2dyYW0uZ2V0U2VtYW50aWNEaWFnbm9zdGljcyhzZikpO1xuICAgICAgfSk7XG4gICAgICBwZXJmVHJhY2Uuc25hcHNob3RNZW1vcnlVc2FnZSgpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGRpYWdub3N0aWNzO1xufVxuXG4vKipcbiAqIGV4cGFuZFNvdXJjZXNGcm9tRGlyZWN0b3JpZXMgZmluZHMgYW55IGRpcmVjdG9yaWVzIHVuZGVyIGZpbGVQYXRoIGFuZCBleHBhbmRzXG4gKiB0aGVtIHRvIHRoZWlyIC5qcyBvciAudHMgY29udGVudHMuXG4gKi9cbmZ1bmN0aW9uIGV4cGFuZFNvdXJjZXNGcm9tRGlyZWN0b3JpZXMoZmlsZUxpc3Q6IHN0cmluZ1tdLCBmaWxlUGF0aDogc3RyaW5nKSB7XG4gIGlmICghZnMuc3RhdFN5bmMoZmlsZVBhdGgpLmlzRGlyZWN0b3J5KCkpIHtcbiAgICBpZiAoZmlsZVBhdGguZW5kc1dpdGgoJy50cycpIHx8IGZpbGVQYXRoLmVuZHNXaXRoKCcudHN4JykgfHxcbiAgICAgICAgZmlsZVBhdGguZW5kc1dpdGgoJy5qcycpKSB7XG4gICAgICBmaWxlTGlzdC5wdXNoKGZpbGVQYXRoKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGVudHJpZXMgPSBmcy5yZWFkZGlyU3luYyhmaWxlUGF0aCk7XG4gIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgIGV4cGFuZFNvdXJjZXNGcm9tRGlyZWN0b3JpZXMoZmlsZUxpc3QsIHBhdGguam9pbihmaWxlUGF0aCwgZW50cnkpKTtcbiAgfVxufVxuXG4vKipcbiAqIFJ1bnMgYSBzaW5nbGUgYnVpbGQsIHJldHVybmluZyBmYWxzZSBvbiBmYWlsdXJlLiAgVGhpcyBpcyBwb3RlbnRpYWxseSBjYWxsZWRcbiAqIG11bHRpcGxlIHRpbWVzIChvbmNlIHBlciBiYXplbCByZXF1ZXN0KSB3aGVuIHJ1bm5pbmcgYXMgYSBiYXplbCB3b3JrZXIuXG4gKiBBbnkgZW5jb3VudGVyZWQgZXJyb3JzIGFyZSB3cml0dGVuIHRvIHN0ZGVyci5cbiAqL1xuZnVuY3Rpb24gcnVuT25lQnVpbGQoXG4gICAgYXJnczogc3RyaW5nW10sIGlucHV0cz86IHtbcGF0aDogc3RyaW5nXTogc3RyaW5nfSk6IGJvb2xlYW4ge1xuICBpZiAoYXJncy5sZW5ndGggIT09IDEpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFeHBlY3RlZCBvbmUgYXJndW1lbnQ6IHBhdGggdG8gdHNjb25maWcuanNvbicpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHBlcmZUcmFjZS5zbmFwc2hvdE1lbW9yeVVzYWdlKCk7XG5cbiAgLy8gU3RyaXAgbGVhZGluZyBhdC1zaWducywgdXNlZCBpbiBidWlsZF9kZWZzLmJ6bCB0byBpbmRpY2F0ZSBhIHBhcmFtcyBmaWxlXG4gIGNvbnN0IHRzY29uZmlnRmlsZSA9IGFyZ3NbMF0ucmVwbGFjZSgvXkArLywgJycpO1xuICBjb25zdCBbcGFyc2VkLCBlcnJvcnMsIHt0YXJnZXR9XSA9IHBhcnNlVHNjb25maWcodHNjb25maWdGaWxlKTtcbiAgaWYgKGVycm9ycykge1xuICAgIGNvbnNvbGUuZXJyb3IoYmF6ZWxEaWFnbm9zdGljcy5mb3JtYXQodGFyZ2V0LCBlcnJvcnMpKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCFwYXJzZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdJbXBvc3NpYmxlIHN0YXRlOiBpZiBwYXJzZVRzY29uZmlnIHJldHVybnMgbm8gZXJyb3JzLCB0aGVuIHBhcnNlZCBzaG91bGQgYmUgbm9uLW51bGwnKTtcbiAgfVxuICBjb25zdCB7XG4gICAgb3B0aW9ucyxcbiAgICBiYXplbE9wdHMsXG4gICAgZmlsZXMsXG4gICAgZGlzYWJsZWRUc2V0c2VSdWxlcyxcbiAgICBhbmd1bGFyQ29tcGlsZXJPcHRpb25zXG4gIH0gPSBwYXJzZWQ7XG5cbiAgY29uc3Qgc291cmNlRmlsZXM6IHN0cmluZ1tdID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZmlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBmaWxlUGF0aCA9IGZpbGVzW2ldO1xuICAgIGV4cGFuZFNvdXJjZXNGcm9tRGlyZWN0b3JpZXMoc291cmNlRmlsZXMsIGZpbGVQYXRoKTtcbiAgfVxuXG4gIGlmIChiYXplbE9wdHMubWF4Q2FjaGVTaXplTWIgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IG1heENhY2hlU2l6ZUJ5dGVzID0gYmF6ZWxPcHRzLm1heENhY2hlU2l6ZU1iICogKDEgPDwgMjApO1xuICAgIGNhY2hlLnNldE1heENhY2hlU2l6ZShtYXhDYWNoZVNpemVCeXRlcyk7XG4gIH0gZWxzZSB7XG4gICAgY2FjaGUucmVzZXRNYXhDYWNoZVNpemUoKTtcbiAgfVxuXG4gIGxldCBmaWxlTG9hZGVyOiBGaWxlTG9hZGVyO1xuICBpZiAoaW5wdXRzKSB7XG4gICAgZmlsZUxvYWRlciA9IG5ldyBDYWNoZWRGaWxlTG9hZGVyKGNhY2hlKTtcbiAgICAvLyBSZXNvbHZlIHRoZSBpbnB1dHMgdG8gYWJzb2x1dGUgcGF0aHMgdG8gbWF0Y2ggVHlwZVNjcmlwdCBpbnRlcm5hbHNcbiAgICBjb25zdCByZXNvbHZlZElucHV0cyA9IG5ldyBNYXA8c3RyaW5nLCBzdHJpbmc+KCk7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoaW5wdXRzKSkge1xuICAgICAgcmVzb2x2ZWRJbnB1dHMuc2V0KHJlc29sdmVOb3JtYWxpemVkUGF0aChrZXkpLCBpbnB1dHNba2V5XSk7XG4gICAgfVxuICAgIGNhY2hlLnVwZGF0ZUNhY2hlKHJlc29sdmVkSW5wdXRzKTtcbiAgfSBlbHNlIHtcbiAgICBmaWxlTG9hZGVyID0gbmV3IFVuY2FjaGVkRmlsZUxvYWRlcigpO1xuICB9XG5cbiAgY29uc3QgcGVyZlRyYWNlUGF0aCA9IGJhemVsT3B0cy5wZXJmVHJhY2VQYXRoO1xuICBpZiAoIXBlcmZUcmFjZVBhdGgpIHtcbiAgICByZXR1cm4gcnVuRnJvbU9wdGlvbnMoXG4gICAgICAgIGZpbGVMb2FkZXIsIG9wdGlvbnMsIGJhemVsT3B0cywgc291cmNlRmlsZXMsIGRpc2FibGVkVHNldHNlUnVsZXMsXG4gICAgICAgIGFuZ3VsYXJDb21waWxlck9wdGlvbnMpO1xuICB9XG5cbiAgbG9nKCdXcml0aW5nIHRyYWNlIHRvJywgcGVyZlRyYWNlUGF0aCk7XG4gIGNvbnN0IHN1Y2Nlc3MgPSBwZXJmVHJhY2Uud3JhcChcbiAgICAgICdydW5PbmVCdWlsZCcsXG4gICAgICAoKSA9PiBydW5Gcm9tT3B0aW9ucyhcbiAgICAgICAgICBmaWxlTG9hZGVyLCBvcHRpb25zLCBiYXplbE9wdHMsIHNvdXJjZUZpbGVzLCBkaXNhYmxlZFRzZXRzZVJ1bGVzLFxuICAgICAgICAgIGFuZ3VsYXJDb21waWxlck9wdGlvbnMpKTtcbiAgaWYgKCFzdWNjZXNzKSByZXR1cm4gZmFsc2U7XG4gIC8vIEZvcmNlIGEgZ2FyYmFnZSBjb2xsZWN0aW9uIHBhc3MuICBUaGlzIGtlZXBzIG91ciBtZW1vcnkgdXNhZ2VcbiAgLy8gY29uc2lzdGVudCBhY3Jvc3MgbXVsdGlwbGUgY29tcGlsYXRpb25zLCBhbmQgYWxsb3dzIHRoZSBmaWxlXG4gIC8vIGNhY2hlIHRvIHVzZSB0aGUgY3VycmVudCBtZW1vcnkgdXNhZ2UgYXMgYSBndWlkZWxpbmUgZm9yIGV4cGlyaW5nXG4gIC8vIGRhdGEuICBOb3RlOiB0aGlzIGlzIGludGVudGlvbmFsbHkgbm90IHdpdGhpbiBydW5Gcm9tT3B0aW9ucygpLCBhc1xuICAvLyB3ZSB3YW50IHRvIGdjIG9ubHkgYWZ0ZXIgYWxsIGl0cyBsb2NhbHMgaGF2ZSBnb25lIG91dCBvZiBzY29wZS5cbiAgZ2xvYmFsLmdjKCk7XG5cbiAgcGVyZlRyYWNlLnNuYXBzaG90TWVtb3J5VXNhZ2UoKTtcbiAgcGVyZlRyYWNlLndyaXRlKHBlcmZUcmFjZVBhdGgpO1xuXG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyBXZSBvbmx5IGFsbG93IG91ciBvd24gY29kZSB0byB1c2UgdGhlIGV4cGVjdGVkX2RpYWdub3N0aWNzIGF0dHJpYnV0ZVxuY29uc3QgZXhwZWN0RGlhZ25vc3RpY3NXaGl0ZWxpc3Q6IHN0cmluZ1tdID0gW1xuXTtcblxuZnVuY3Rpb24gcnVuRnJvbU9wdGlvbnMoXG4gICAgZmlsZUxvYWRlcjogRmlsZUxvYWRlciwgb3B0aW9uczogdHMuQ29tcGlsZXJPcHRpb25zLFxuICAgIGJhemVsT3B0czogQmF6ZWxPcHRpb25zLCBmaWxlczogc3RyaW5nW10sIGRpc2FibGVkVHNldHNlUnVsZXM6IHN0cmluZ1tdLFxuICAgIGFuZ3VsYXJDb21waWxlck9wdGlvbnM/OiB7W2tleTogc3RyaW5nXTogdW5rbm93bn0pOiBib29sZWFuIHtcbiAgcGVyZlRyYWNlLnNuYXBzaG90TWVtb3J5VXNhZ2UoKTtcbiAgY2FjaGUucmVzZXRTdGF0cygpO1xuICBjYWNoZS50cmFjZVN0YXRzKCk7XG5cbiAgY29uc3QgY29tcGlsZXJIb3N0RGVsZWdhdGUgPVxuICAgICAgdHMuY3JlYXRlQ29tcGlsZXJIb3N0KHt0YXJnZXQ6IHRzLlNjcmlwdFRhcmdldC5FUzV9KTtcblxuICBjb25zdCBtb2R1bGVSZXNvbHZlciA9IGJhemVsT3B0cy5pc0pzVHJhbnNwaWxhdGlvbiA/XG4gICAgICBtYWtlSnNNb2R1bGVSZXNvbHZlcihiYXplbE9wdHMud29ya3NwYWNlTmFtZSkgOlxuICAgICAgdHMucmVzb2x2ZU1vZHVsZU5hbWU7XG4gIGNvbnN0IHRzaWNrbGVDb21waWxlckhvc3QgPSBuZXcgQ29tcGlsZXJIb3N0KFxuICAgICAgZmlsZXMsIG9wdGlvbnMsIGJhemVsT3B0cywgY29tcGlsZXJIb3N0RGVsZWdhdGUsIGZpbGVMb2FkZXIsXG4gICAgICBtb2R1bGVSZXNvbHZlcik7XG4gIGxldCBjb21waWxlckhvc3Q6IFBsdWdpbkNvbXBpbGVySG9zdCA9IHRzaWNrbGVDb21waWxlckhvc3Q7XG5cbiAgbGV0IGFuZ3VsYXJQbHVnaW46IFRzY1BsdWdpbnx1bmRlZmluZWQ7XG4gIGlmIChiYXplbE9wdHMuY29tcGlsZUFuZ3VsYXJUZW1wbGF0ZXMpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgbmdPcHRpb25zID0gYW5ndWxhckNvbXBpbGVyT3B0aW9ucyB8fCB7fTtcbiAgICAgIC8vIEFkZCB0aGUgcm9vdERpciBzZXR0aW5nIHRvIHRoZSBvcHRpb25zIHBhc3NlZCB0byBOZ1RzY1BsdWdpbi5cbiAgICAgIC8vIFJlcXVpcmVkIHNvIHRoYXQgc3ludGhldGljIGZpbGVzIGFkZGVkIHRvIHRoZSByb290RmlsZXMgaW4gdGhlIHByb2dyYW1cbiAgICAgIC8vIGNhbiBiZSBnaXZlbiBhYnNvbHV0ZSBwYXRocywganVzdCBhcyB3ZSBkbyBpbiB0c2NvbmZpZy50cywgbWF0Y2hpbmdcbiAgICAgIC8vIHRoZSBiZWhhdmlvciBpbiBUeXBlU2NyaXB0J3MgdHNjb25maWcgcGFyc2luZyBsb2dpYy5cbiAgICAgIG5nT3B0aW9uc1sncm9vdERpciddID0gb3B0aW9ucy5yb290RGlyO1xuXG4gICAgICAvLyBEeW5hbWljYWxseSBsb2FkIHRoZSBBbmd1bGFyIGNvbXBpbGVyIGluc3RhbGxlZCBhcyBhIHBlZXJEZXBcbiAgICAgIGNvbnN0IG5ndHNjID0gcmVxdWlyZSgnQGFuZ3VsYXIvY29tcGlsZXItY2xpJyk7XG4gICAgICBhbmd1bGFyUGx1Z2luID0gbmV3IG5ndHNjLk5nVHNjUGx1Z2luKG5nT3B0aW9ucyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnd2hlbiB1c2luZyBgdHNfbGlicmFyeShjb21waWxlX2FuZ3VsYXJfdGVtcGxhdGVzPVRydWUpYCwgJyArXG4gICAgICAgICAgJ3lvdSBtdXN0IGluc3RhbGwgQGFuZ3VsYXIvY29tcGlsZXItY2xpJyk7XG4gICAgfVxuXG4gICAgLy8gV3JhcCBob3N0IG9ubHkgbmVlZGVkIHVudGlsIGFmdGVyIEl2eSBjbGVhbnVwXG4gICAgLy8gVE9ETyhhbGV4ZWFnbGUpOiByZW1vdmUgYWZ0ZXIgbmdzdW1tYXJ5IGFuZCBuZ2ZhY3RvcnkgZmlsZXMgZWxpbWluYXRlZFxuICAgIGNvbXBpbGVySG9zdCA9IGFuZ3VsYXJQbHVnaW4hLndyYXBIb3N0IShmaWxlcywgY29tcGlsZXJIb3N0KTtcbiAgfVxuXG5cbiAgY29uc3Qgb2xkUHJvZ3JhbSA9IGNhY2hlLmdldFByb2dyYW0oYmF6ZWxPcHRzLnRhcmdldCk7XG4gIGNvbnN0IHByb2dyYW0gPSBwZXJmVHJhY2Uud3JhcChcbiAgICAgICdjcmVhdGVQcm9ncmFtJyxcbiAgICAgICgpID0+IHRzLmNyZWF0ZVByb2dyYW0oXG4gICAgICAgICAgY29tcGlsZXJIb3N0LmlucHV0RmlsZXMsIG9wdGlvbnMsIGNvbXBpbGVySG9zdCwgb2xkUHJvZ3JhbSkpO1xuICBjYWNoZS5wdXRQcm9ncmFtKGJhemVsT3B0cy50YXJnZXQsIHByb2dyYW0pO1xuXG4gIGlmICghYmF6ZWxPcHRzLmlzSnNUcmFuc3BpbGF0aW9uKSB7XG4gICAgLy8gSWYgdGhlcmUgYXJlIGFueSBUeXBlU2NyaXB0IHR5cGUgZXJyb3JzIGFib3J0IG5vdywgc28gdGhlIGVycm9yXG4gICAgLy8gbWVzc2FnZXMgcmVmZXIgdG8gdGhlIG9yaWdpbmFsIHNvdXJjZS4gIEFmdGVyIGFueSBzdWJzZXF1ZW50IHBhc3Nlc1xuICAgIC8vIChkZWNvcmF0b3IgZG93bmxldmVsaW5nIG9yIHRzaWNrbGUpIHdlIGRvIG5vdCB0eXBlIGNoZWNrLlxuICAgIGxldCBkaWFnbm9zdGljcyA9IGdhdGhlckRpYWdub3N0aWNzKFxuICAgICAgICBvcHRpb25zLCBiYXplbE9wdHMsIHByb2dyYW0sIGRpc2FibGVkVHNldHNlUnVsZXMsIGFuZ3VsYXJQbHVnaW4pO1xuICAgIGlmICghZXhwZWN0RGlhZ25vc3RpY3NXaGl0ZWxpc3QubGVuZ3RoIHx8XG4gICAgICAgIGV4cGVjdERpYWdub3N0aWNzV2hpdGVsaXN0LnNvbWUocCA9PiBiYXplbE9wdHMudGFyZ2V0LnN0YXJ0c1dpdGgocCkpKSB7XG4gICAgICBkaWFnbm9zdGljcyA9IGJhemVsRGlhZ25vc3RpY3MuZmlsdGVyRXhwZWN0ZWQoXG4gICAgICAgICAgYmF6ZWxPcHRzLCBkaWFnbm9zdGljcywgYmF6ZWxEaWFnbm9zdGljcy51Z2x5Rm9ybWF0KTtcbiAgICB9IGVsc2UgaWYgKGJhemVsT3B0cy5leHBlY3RlZERpYWdub3N0aWNzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgYE9ubHkgdGFyZ2V0cyB1bmRlciAke1xuICAgICAgICAgICAgICBleHBlY3REaWFnbm9zdGljc1doaXRlbGlzdC5qb2luKCcsICcpfSBjYW4gdXNlIGAgK1xuICAgICAgICAgICAgICAnZXhwZWN0ZWRfZGlhZ25vc3RpY3MsIGJ1dCBnb3QnLFxuICAgICAgICAgIGJhemVsT3B0cy50YXJnZXQpO1xuICAgIH1cblxuICAgIGlmIChkaWFnbm9zdGljcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGJhemVsRGlhZ25vc3RpY3MuZm9ybWF0KGJhemVsT3B0cy50YXJnZXQsIGRpYWdub3N0aWNzKSk7XG4gICAgICBkZWJ1ZygnY29tcGlsYXRpb24gZmFpbGVkIGF0JywgbmV3IEVycm9yKCkuc3RhY2shKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBjb21waWxhdGlvblRhcmdldHMgPSBwcm9ncmFtLmdldFNvdXJjZUZpbGVzKCkuZmlsdGVyKFxuICAgICAgZmlsZU5hbWUgPT4gaXNDb21waWxhdGlvblRhcmdldChiYXplbE9wdHMsIGZpbGVOYW1lKSk7XG5cbiAgbGV0IGRpYWdub3N0aWNzOiB0cy5EaWFnbm9zdGljW10gPSBbXTtcbiAgbGV0IHVzZVRzaWNrbGVFbWl0ID0gYmF6ZWxPcHRzLnRzaWNrbGU7XG4gIGxldCB0cmFuc2Zvcm1zOiB0cy5DdXN0b21UcmFuc2Zvcm1lcnMgPSB7XG4gICAgYmVmb3JlOiBbXSxcbiAgICBhZnRlcjogW10sXG4gICAgYWZ0ZXJEZWNsYXJhdGlvbnM6IFtdLFxuICB9O1xuXG4gIGlmIChhbmd1bGFyUGx1Z2luKSB7XG4gICAgdHJhbnNmb3JtcyA9IGFuZ3VsYXJQbHVnaW4uY3JlYXRlVHJhbnNmb3JtZXJzIShjb21waWxlckhvc3QpO1xuICB9XG5cbiAgaWYgKHVzZVRzaWNrbGVFbWl0KSB7XG4gICAgZGlhZ25vc3RpY3MgPSBlbWl0V2l0aFRzaWNrbGUoXG4gICAgICAgIHByb2dyYW0sIHRzaWNrbGVDb21waWxlckhvc3QsIGNvbXBpbGF0aW9uVGFyZ2V0cywgb3B0aW9ucywgYmF6ZWxPcHRzLFxuICAgICAgICB0cmFuc2Zvcm1zKTtcbiAgfSBlbHNlIHtcbiAgICBkaWFnbm9zdGljcyA9IGVtaXRXaXRoVHlwZXNjcmlwdChwcm9ncmFtLCBjb21waWxhdGlvblRhcmdldHMsIHRyYW5zZm9ybXMpO1xuICB9XG5cbiAgaWYgKGRpYWdub3N0aWNzLmxlbmd0aCA+IDApIHtcbiAgICBjb25zb2xlLmVycm9yKGJhemVsRGlhZ25vc3RpY3MuZm9ybWF0KGJhemVsT3B0cy50YXJnZXQsIGRpYWdub3N0aWNzKSk7XG4gICAgZGVidWcoJ2NvbXBpbGF0aW9uIGZhaWxlZCBhdCcsIG5ldyBFcnJvcigpLnN0YWNrISk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY2FjaGUucHJpbnRTdGF0cygpO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZW1pdFdpdGhUeXBlc2NyaXB0KFxuICAgIHByb2dyYW06IHRzLlByb2dyYW0sIGNvbXBpbGF0aW9uVGFyZ2V0czogdHMuU291cmNlRmlsZVtdLFxuICAgIHRyYW5zZm9ybXM6IHRzLkN1c3RvbVRyYW5zZm9ybWVycyk6IHRzLkRpYWdub3N0aWNbXSB7XG4gIGNvbnN0IGRpYWdub3N0aWNzOiB0cy5EaWFnbm9zdGljW10gPSBbXTtcbiAgZm9yIChjb25zdCBzZiBvZiBjb21waWxhdGlvblRhcmdldHMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBwcm9ncmFtLmVtaXQoXG4gICAgICAgIHNmLCAvKndyaXRlRmlsZSovIHVuZGVmaW5lZCxcbiAgICAgICAgLypjYW5jZWxsYXRpb25Ub2tlbiovIHVuZGVmaW5lZCwgLyplbWl0T25seUR0c0ZpbGVzKi8gdW5kZWZpbmVkLFxuICAgICAgICB0cmFuc2Zvcm1zKTtcbiAgICBkaWFnbm9zdGljcy5wdXNoKC4uLnJlc3VsdC5kaWFnbm9zdGljcyk7XG4gIH1cbiAgcmV0dXJuIGRpYWdub3N0aWNzO1xufVxuXG4vKipcbiAqIFJ1bnMgdGhlIGVtaXQgcGlwZWxpbmUgd2l0aCBUc2lja2xlIHRyYW5zZm9ybWF0aW9ucyAtIGdvb2cubW9kdWxlIHJld3JpdGluZ1xuICogYW5kIENsb3N1cmUgdHlwZXMgZW1pdHRlZCBpbmNsdWRlZC5cbiAqIEV4cG9ydGVkIHRvIGJlIHVzZWQgYnkgdGhlIGludGVybmFsIGdsb2JhbCByZWZhY3RvcmluZyB0b29scy5cbiAqIFRPRE8ocmFkb2tpcm92KTogaW52ZXN0aWdhdGUgdXNpbmcgcnVuV2l0aE9wdGlvbnMgYW5kIG1ha2luZyB0aGlzIHByaXZhdGVcbiAqIGFnYWluLCBpZiB3ZSBjYW4gbWFrZSBjb21waWxlckhvc3RzIG1hdGNoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZW1pdFdpdGhUc2lja2xlKFxuICAgIHByb2dyYW06IHRzLlByb2dyYW0sIGNvbXBpbGVySG9zdDogQ29tcGlsZXJIb3N0LFxuICAgIGNvbXBpbGF0aW9uVGFyZ2V0czogdHMuU291cmNlRmlsZVtdLCBvcHRpb25zOiB0cy5Db21waWxlck9wdGlvbnMsXG4gICAgYmF6ZWxPcHRzOiBCYXplbE9wdGlvbnMsXG4gICAgdHJhbnNmb3JtczogdHMuQ3VzdG9tVHJhbnNmb3JtZXJzKTogdHMuRGlhZ25vc3RpY1tdIHtcbiAgY29uc3QgZW1pdFJlc3VsdHM6IHRzaWNrbGUuRW1pdFJlc3VsdFtdID0gW107XG4gIGNvbnN0IGRpYWdub3N0aWNzOiB0cy5EaWFnbm9zdGljW10gPSBbXTtcbiAgLy8gVGhlICd0c2lja2xlJyBpbXBvcnQgYWJvdmUgaXMgb25seSB1c2VkIGluIHR5cGUgcG9zaXRpb25zLCBzbyBpdCB3b24ndFxuICAvLyByZXN1bHQgaW4gYSBydW50aW1lIGRlcGVuZGVuY3kgb24gdHNpY2tsZS5cbiAgLy8gSWYgdGhlIHVzZXIgcmVxdWVzdHMgdGhlIHRzaWNrbGUgZW1pdCwgdGhlbiB3ZSBkeW5hbWljYWxseSByZXF1aXJlIGl0XG4gIC8vIGhlcmUgZm9yIHVzZSBhdCBydW50aW1lLlxuICBsZXQgb3B0VHNpY2tsZTogdHlwZW9mIHRzaWNrbGU7XG4gIHRyeSB7XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLXJlcXVpcmUtaW1wb3J0c1xuICAgIG9wdFRzaWNrbGUgPSByZXF1aXJlKCd0c2lja2xlJyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoZS5jb2RlICE9PSAnTU9EVUxFX05PVF9GT1VORCcpIHtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1doZW4gc2V0dGluZyBiYXplbE9wdHMgeyB0c2lja2xlOiB0cnVlIH0sICcgK1xuICAgICAgICAneW91IG11c3QgYWxzbyBhZGQgYSBkZXZEZXBlbmRlbmN5IG9uIHRoZSB0c2lja2xlIG5wbSBwYWNrYWdlJyk7XG4gIH1cbiAgcGVyZlRyYWNlLndyYXAoJ2VtaXQnLCAoKSA9PiB7XG4gICAgZm9yIChjb25zdCBzZiBvZiBjb21waWxhdGlvblRhcmdldHMpIHtcbiAgICAgIHBlcmZUcmFjZS53cmFwKGBlbWl0ICR7c2YuZmlsZU5hbWV9YCwgKCkgPT4ge1xuICAgICAgICBlbWl0UmVzdWx0cy5wdXNoKG9wdFRzaWNrbGUuZW1pdFdpdGhUc2lja2xlKFxuICAgICAgICAgICAgcHJvZ3JhbSwgY29tcGlsZXJIb3N0LCBjb21waWxlckhvc3QsIG9wdGlvbnMsIHNmLFxuICAgICAgICAgICAgLyp3cml0ZUZpbGUqLyB1bmRlZmluZWQsXG4gICAgICAgICAgICAvKmNhbmNlbGxhdGlvblRva2VuKi8gdW5kZWZpbmVkLCAvKmVtaXRPbmx5RHRzRmlsZXMqLyB1bmRlZmluZWQsIHtcbiAgICAgICAgICAgICAgYmVmb3JlVHM6IHRyYW5zZm9ybXMuYmVmb3JlLFxuICAgICAgICAgICAgICBhZnRlclRzOiB0cmFuc2Zvcm1zLmFmdGVyLFxuICAgICAgICAgICAgICBhZnRlckRlY2xhcmF0aW9uczogdHJhbnNmb3Jtcy5hZnRlckRlY2xhcmF0aW9ucyxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IGVtaXRSZXN1bHQgPSBvcHRUc2lja2xlLm1lcmdlRW1pdFJlc3VsdHMoZW1pdFJlc3VsdHMpO1xuICBkaWFnbm9zdGljcy5wdXNoKC4uLmVtaXRSZXN1bHQuZGlhZ25vc3RpY3MpO1xuXG4gIC8vIElmIHRzaWNrbGUgcmVwb3J0ZWQgZGlhZ25vc3RpY3MsIGRvbid0IHByb2R1Y2UgZXh0ZXJucyBvciBtYW5pZmVzdCBvdXRwdXRzLlxuICBpZiAoZGlhZ25vc3RpY3MubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBkaWFnbm9zdGljcztcbiAgfVxuXG4gIGxldCBleHRlcm5zID0gJy8qKiBAZXh0ZXJucyAqL1xcbicgK1xuICAgICAgJy8vIGdlbmVyYXRpbmcgZXh0ZXJucyB3YXMgZGlzYWJsZWQgdXNpbmcgZ2VuZXJhdGVfZXh0ZXJucz1GYWxzZVxcbic7XG4gIGlmIChiYXplbE9wdHMudHNpY2tsZUdlbmVyYXRlRXh0ZXJucykge1xuICAgIGV4dGVybnMgPVxuICAgICAgICBvcHRUc2lja2xlLmdldEdlbmVyYXRlZEV4dGVybnMoZW1pdFJlc3VsdC5leHRlcm5zLCBvcHRpb25zLnJvb3REaXIhKTtcbiAgfVxuXG4gIGlmIChiYXplbE9wdHMudHNpY2tsZUV4dGVybnNQYXRoKSB7XG4gICAgLy8gTm90ZTogd2hlbiB0c2lja2xlRXh0ZXJuc1BhdGggaXMgcHJvdmlkZWQsIHdlIGFsd2F5cyB3cml0ZSBhIGZpbGUgYXMgYVxuICAgIC8vIG1hcmtlciB0aGF0IGNvbXBpbGF0aW9uIHN1Y2NlZWRlZCwgZXZlbiBpZiBpdCdzIGVtcHR5IChqdXN0IGNvbnRhaW5pbmcgYW5cbiAgICAvLyBAZXh0ZXJucykuXG4gICAgZnMud3JpdGVGaWxlU3luYyhiYXplbE9wdHMudHNpY2tsZUV4dGVybnNQYXRoLCBleHRlcm5zKTtcblxuICAgIC8vIFdoZW4gZ2VuZXJhdGluZyBleHRlcm5zLCBnZW5lcmF0ZSBhbiBleHRlcm5zIGZpbGUgZm9yIGVhY2ggb2YgdGhlIGlucHV0XG4gICAgLy8gLmQudHMgZmlsZXMuXG4gICAgaWYgKGJhemVsT3B0cy50c2lja2xlR2VuZXJhdGVFeHRlcm5zICYmXG4gICAgICAgIGNvbXBpbGVySG9zdC5wcm92aWRlRXh0ZXJuYWxNb2R1bGVEdHNOYW1lc3BhY2UpIHtcbiAgICAgIGZvciAoY29uc3QgZXh0ZXJuIG9mIGNvbXBpbGF0aW9uVGFyZ2V0cykge1xuICAgICAgICBpZiAoIWV4dGVybi5pc0RlY2xhcmF0aW9uRmlsZSkgY29udGludWU7XG4gICAgICAgIGNvbnN0IG91dHB1dEJhc2VEaXIgPSBvcHRpb25zLm91dERpciE7XG4gICAgICAgIGNvbnN0IHJlbGF0aXZlT3V0cHV0UGF0aCA9XG4gICAgICAgICAgICBjb21waWxlckhvc3QucmVsYXRpdmVPdXRwdXRQYXRoKGV4dGVybi5maWxlTmFtZSk7XG4gICAgICAgIG1rZGlycChvdXRwdXRCYXNlRGlyLCBwYXRoLmRpcm5hbWUocmVsYXRpdmVPdXRwdXRQYXRoKSk7XG4gICAgICAgIGNvbnN0IG91dHB1dFBhdGggPSBwYXRoLmpvaW4ob3V0cHV0QmFzZURpciwgcmVsYXRpdmVPdXRwdXRQYXRoKTtcbiAgICAgICAgY29uc3QgbW9kdWxlTmFtZSA9IGNvbXBpbGVySG9zdC5wYXRoVG9Nb2R1bGVOYW1lKCcnLCBleHRlcm4uZmlsZU5hbWUpO1xuICAgICAgICBmcy53cml0ZUZpbGVTeW5jKFxuICAgICAgICAgICAgb3V0cHV0UGF0aCxcbiAgICAgICAgICAgIGBnb29nLm1vZHVsZSgnJHttb2R1bGVOYW1lfScpO1xcbmAgK1xuICAgICAgICAgICAgICAgIGAvLyBFeHBvcnQgYW4gZW1wdHkgb2JqZWN0IG9mIHVua25vd24gdHlwZSB0byBhbGxvdyBpbXBvcnRzLlxcbmAgK1xuICAgICAgICAgICAgICAgIGAvLyBUT0RPOiB1c2UgdHlwZW9mIG9uY2UgYXZhaWxhYmxlXFxuYCArXG4gICAgICAgICAgICAgICAgYGV4cG9ydHMgPSAvKiogQHR5cGUgez99ICovICh7fSk7XFxuYCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGJhemVsT3B0cy5tYW5pZmVzdCkge1xuICAgIHBlcmZUcmFjZS53cmFwKCdtYW5pZmVzdCcsICgpID0+IHtcbiAgICAgIGNvbnN0IG1hbmlmZXN0ID1cbiAgICAgICAgICBjb25zdHJ1Y3RNYW5pZmVzdChlbWl0UmVzdWx0Lm1vZHVsZXNNYW5pZmVzdCwgY29tcGlsZXJIb3N0KTtcbiAgICAgIGZzLndyaXRlRmlsZVN5bmMoYmF6ZWxPcHRzLm1hbmlmZXN0LCBtYW5pZmVzdCk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gZGlhZ25vc3RpY3M7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBkaXJlY3RvcmllcyBzdWJkaXIgKGEgc2xhc2ggc2VwYXJhdGVkIHJlbGF0aXZlIHBhdGgpIHN0YXJ0aW5nIGZyb21cbiAqIGJhc2UuXG4gKi9cbmZ1bmN0aW9uIG1rZGlycChiYXNlOiBzdHJpbmcsIHN1YmRpcjogc3RyaW5nKSB7XG4gIGNvbnN0IHN0ZXBzID0gc3ViZGlyLnNwbGl0KHBhdGguc2VwKTtcbiAgbGV0IGN1cnJlbnQgPSBiYXNlO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ZXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgY3VycmVudCA9IHBhdGguam9pbihjdXJyZW50LCBzdGVwc1tpXSk7XG4gICAgaWYgKCFmcy5leGlzdHNTeW5jKGN1cnJlbnQpKSBmcy5ta2RpclN5bmMoY3VycmVudCk7XG4gIH1cbn1cblxuXG4vKipcbiAqIFJlc29sdmUgbW9kdWxlIGZpbGVuYW1lcyBmb3IgSlMgbW9kdWxlcy5cbiAqXG4gKiBKUyBtb2R1bGUgcmVzb2x1dGlvbiBuZWVkcyB0byBiZSBkaWZmZXJlbnQgYmVjYXVzZSB3aGVuIHRyYW5zcGlsaW5nIEpTIHdlXG4gKiBkbyBub3QgcGFzcyBpbiBhbnkgZGVwZW5kZW5jaWVzLCBzbyB0aGUgVFMgbW9kdWxlIHJlc29sdmVyIHdpbGwgbm90IHJlc29sdmVcbiAqIGFueSBmaWxlcy5cbiAqXG4gKiBGb3J0dW5hdGVseSwgSlMgbW9kdWxlIHJlc29sdXRpb24gaXMgdmVyeSBzaW1wbGUuIFRoZSBpbXBvcnRlZCBtb2R1bGUgbmFtZVxuICogbXVzdCBlaXRoZXIgYSByZWxhdGl2ZSBwYXRoLCBvciB0aGUgd29ya3NwYWNlIHJvb3QgKGkuZS4gJ2dvb2dsZTMnKSxcbiAqIHNvIHdlIGNhbiBwZXJmb3JtIG1vZHVsZSByZXNvbHV0aW9uIGVudGlyZWx5IGJhc2VkIG9uIGZpbGUgbmFtZXMsIHdpdGhvdXRcbiAqIGxvb2tpbmcgYXQgdGhlIGZpbGVzeXN0ZW0uXG4gKi9cbmZ1bmN0aW9uIG1ha2VKc01vZHVsZVJlc29sdmVyKHdvcmtzcGFjZU5hbWU6IHN0cmluZykge1xuICAvLyBUaGUgbGl0ZXJhbCAnLycgaGVyZSBpcyBjcm9zcy1wbGF0Zm9ybSBzYWZlIGJlY2F1c2UgaXQncyBtYXRjaGluZyBvblxuICAvLyBpbXBvcnQgc3BlY2lmaWVycywgbm90IGZpbGUgbmFtZXMuXG4gIGNvbnN0IHdvcmtzcGFjZU1vZHVsZVNwZWNpZmllclByZWZpeCA9IGAke3dvcmtzcGFjZU5hbWV9L2A7XG4gIGNvbnN0IHdvcmtzcGFjZURpciA9IGAke3BhdGguc2VwfSR7d29ya3NwYWNlTmFtZX0ke3BhdGguc2VwfWA7XG4gIGZ1bmN0aW9uIGpzTW9kdWxlUmVzb2x2ZXIoXG4gICAgICBtb2R1bGVOYW1lOiBzdHJpbmcsIGNvbnRhaW5pbmdGaWxlOiBzdHJpbmcsXG4gICAgICBjb21waWxlck9wdGlvbnM6IHRzLkNvbXBpbGVyT3B0aW9ucywgaG9zdDogdHMuTW9kdWxlUmVzb2x1dGlvbkhvc3QpOlxuICAgICAgdHMuUmVzb2x2ZWRNb2R1bGVXaXRoRmFpbGVkTG9va3VwTG9jYXRpb25zIHtcbiAgICBsZXQgcmVzb2x2ZWRGaWxlTmFtZTtcbiAgICBpZiAoY29udGFpbmluZ0ZpbGUgPT09ICcnKSB7XG4gICAgICAvLyBJbiB0c2lja2xlIHdlIHJlc29sdmUgdGhlIGZpbGVuYW1lIGFnYWluc3QgJycgdG8gZ2V0IHRoZSBnb29nIG1vZHVsZVxuICAgICAgLy8gbmFtZSBvZiBhIHNvdXJjZWZpbGUuXG4gICAgICByZXNvbHZlZEZpbGVOYW1lID0gbW9kdWxlTmFtZTtcbiAgICB9IGVsc2UgaWYgKG1vZHVsZU5hbWUuc3RhcnRzV2l0aCh3b3Jrc3BhY2VNb2R1bGVTcGVjaWZpZXJQcmVmaXgpKSB7XG4gICAgICAvLyBHaXZlbiBhIHdvcmtzcGFjZSBuYW1lIG9mICdmb28nLCB3ZSB3YW50IHRvIHJlc29sdmUgaW1wb3J0IHNwZWNpZmllcnNcbiAgICAgIC8vIGxpa2U6ICdmb28vcHJvamVjdC9maWxlLmpzJyB0byB0aGUgYWJzb2x1dGUgZmlsZXN5c3RlbSBwYXRoIG9mXG4gICAgICAvLyBwcm9qZWN0L2ZpbGUuanMgd2l0aGluIHRoZSB3b3Jrc3BhY2UuXG4gICAgICBjb25zdCB3b3Jrc3BhY2VEaXJMb2NhdGlvbiA9IGNvbnRhaW5pbmdGaWxlLmluZGV4T2Yod29ya3NwYWNlRGlyKTtcbiAgICAgIGlmICh3b3Jrc3BhY2VEaXJMb2NhdGlvbiA8IDApIHtcbiAgICAgICAgcmV0dXJuIHtyZXNvbHZlZE1vZHVsZTogdW5kZWZpbmVkfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFic29sdXRlUGF0aFRvV29ya3NwYWNlRGlyID1cbiAgICAgICAgICBjb250YWluaW5nRmlsZS5zbGljZSgwLCB3b3Jrc3BhY2VEaXJMb2NhdGlvbik7XG4gICAgICByZXNvbHZlZEZpbGVOYW1lID0gcGF0aC5qb2luKGFic29sdXRlUGF0aFRvV29ya3NwYWNlRGlyLCBtb2R1bGVOYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFtb2R1bGVOYW1lLnN0YXJ0c1dpdGgoJy4vJykgJiYgIW1vZHVsZU5hbWUuc3RhcnRzV2l0aCgnLi4vJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYFVuc3VwcG9ydGVkIG1vZHVsZSBpbXBvcnQgc3BlY2lmaWVyOiAke1xuICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KG1vZHVsZU5hbWUpfS5cXG5gICtcbiAgICAgICAgICAgIGBKUyBtb2R1bGUgaW1wb3J0cyBtdXN0IGVpdGhlciBiZSByZWxhdGl2ZSBwYXRocyBgICtcbiAgICAgICAgICAgIGAoYmVnaW5uaW5nIHdpdGggJy4nIG9yICcuLicpLCBgICtcbiAgICAgICAgICAgIGBvciB0aGV5IG11c3QgYmVnaW4gd2l0aCAnJHt3b3Jrc3BhY2VOYW1lfS8nLmApO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZWRGaWxlTmFtZSA9IHBhdGguam9pbihwYXRoLmRpcm5hbWUoY29udGFpbmluZ0ZpbGUpLCBtb2R1bGVOYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc29sdmVkTW9kdWxlOiB7XG4gICAgICAgIHJlc29sdmVkRmlsZU5hbWUsXG4gICAgICAgIGV4dGVuc2lvbjogdHMuRXh0ZW5zaW9uLkpzLCAgLy8ganMgY2FuIG9ubHkgaW1wb3J0IGpzXG4gICAgICAgIC8vIFRoZXNlIHR3byBmaWVsZHMgYXJlIGNhcmdvIGN1bHRlZCBmcm9tIHdoYXQgdHMucmVzb2x2ZU1vZHVsZU5hbWVcbiAgICAgICAgLy8gc2VlbXMgdG8gcmV0dXJuLlxuICAgICAgICBwYWNrYWdlSWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgaXNFeHRlcm5hbExpYnJhcnlJbXBvcnQ6IGZhbHNlLFxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICByZXR1cm4ganNNb2R1bGVSZXNvbHZlcjtcbn1cblxuXG5pZiAocmVxdWlyZS5tYWluID09PSBtb2R1bGUpIHtcbiAgLy8gRG8gbm90IGNhbGwgcHJvY2Vzcy5leGl0KCksIGFzIHRoYXQgdGVybWluYXRlcyB0aGUgYmluYXJ5IGJlZm9yZVxuICAvLyBjb21wbGV0aW5nIHBlbmRpbmcgb3BlcmF0aW9ucywgc3VjaCBhcyB3cml0aW5nIHRvIHN0ZG91dCBvciBlbWl0dGluZyB0aGVcbiAgLy8gdjggcGVyZm9ybWFuY2UgbG9nLiBSYXRoZXIsIHNldCB0aGUgZXhpdCBjb2RlIGFuZCBmYWxsIG9mZiB0aGUgbWFpblxuICAvLyB0aHJlYWQsIHdoaWNoIHdpbGwgY2F1c2Ugbm9kZSB0byB0ZXJtaW5hdGUgY2xlYW5seS5cbiAgcHJvY2Vzcy5leGl0Q29kZSA9IG1haW4ocHJvY2Vzcy5hcmd2LnNsaWNlKDIpKTtcbn1cbiJdfQ==