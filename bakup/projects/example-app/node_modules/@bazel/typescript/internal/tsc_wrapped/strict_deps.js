/**
 * @license
 * Copyright 2017 The Bazel Authors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 *
 * You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "path", "typescript", "./perf_trace", "./plugin_api"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const path = require("path");
    const ts = require("typescript");
    const perfTrace = require("./perf_trace");
    const pluginApi = require("./plugin_api");
    /** The TypeScript diagnostic code for "Cannot find module ...". */
    exports.TS_ERR_CANNOT_FIND_MODULE = 2307;
    /**
     * The strict_deps plugin checks the imports of the compiled modules.
     *
     * It implements strict deps, i.e. enforces that each file in
     * `config.compilationTargetSrc` only imports from files in
     * `config.allowedStrictDeps`.
     *
     * This is used to implement strict dependency checking -
     * source files in a build target may only import sources of their immediate
     * dependencies, but not sources of their transitive dependencies.
     *
     * strict_deps also makes sure that no imports ends in '.ts'. TypeScript
     * allows imports including the file extension, but our runtime loading support
     * fails with it.
     *
     * strict_deps currently does not check ambient/global definitions.
     */
    exports.PLUGIN = {
        wrap: (program, config) => {
            const proxy = pluginApi.createProxy(program);
            proxy.getSemanticDiagnostics = function (sourceFile) {
                const result = [...program.getSemanticDiagnostics(sourceFile)];
                perfTrace.wrap('checkModuleDeps', () => {
                    result.push(...checkModuleDeps(sourceFile, program.getTypeChecker(), config.allowedStrictDeps, config.rootDir));
                });
                return result;
            };
            return proxy;
        }
    };
    // Exported for testing
    function checkModuleDeps(sf, tc, allowedDeps, rootDir) {
        function stripExt(fn) {
            return fn.replace(/(\.d)?\.tsx?$/, '');
        }
        const allowedMap = {};
        for (const d of allowedDeps)
            allowedMap[stripExt(d)] = true;
        const result = [];
        for (const stmt of sf.statements) {
            if (stmt.kind !== ts.SyntaxKind.ImportDeclaration &&
                stmt.kind !== ts.SyntaxKind.ExportDeclaration) {
                continue;
            }
            const id = stmt;
            const modSpec = id.moduleSpecifier;
            if (!modSpec)
                continue; // E.g. a bare "export {x};"
            const sym = tc.getSymbolAtLocation(modSpec);
            if (!sym || !sym.declarations || sym.declarations.length < 1) {
                continue;
            }
            // Module imports can only have one declaration location.
            const declFileName = sym.declarations[0].getSourceFile().fileName;
            if (allowedMap[stripExt(declFileName)])
                continue;
            const importName = path.posix.relative(rootDir, declFileName);
            result.push({
                file: sf,
                start: modSpec.getStart(),
                length: modSpec.getEnd() - modSpec.getStart(),
                messageText: `transitive dependency on ${importName} not allowed. ` +
                    `Please add the BUILD target to your rule's deps.`,
                category: ts.DiagnosticCategory.Error,
                // semantics are close enough, needs taze.
                code: exports.TS_ERR_CANNOT_FIND_MODULE,
            });
        }
        return result;
    }
    exports.checkModuleDeps = checkModuleDeps;
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RyaWN0X2RlcHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9leHRlcm5hbC9idWlsZF9iYXplbF9ydWxlc190eXBlc2NyaXB0L2ludGVybmFsL3RzY193cmFwcGVkL3N0cmljdF9kZXBzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7R0FlRzs7Ozs7Ozs7Ozs7O0lBRUgsNkJBQTZCO0lBQzdCLGlDQUFpQztJQUVqQywwQ0FBMEM7SUFDMUMsMENBQTBDO0lBUTFDLG1FQUFtRTtJQUN0RCxRQUFBLHlCQUF5QixHQUFHLElBQUksQ0FBQztJQUU5Qzs7Ozs7Ozs7Ozs7Ozs7OztPQWdCRztJQUNVLFFBQUEsTUFBTSxHQUFxQjtRQUN0QyxJQUFJLEVBQUUsQ0FBQyxPQUFtQixFQUFFLE1BQThCLEVBQWMsRUFBRTtZQUN4RSxNQUFNLEtBQUssR0FBRyxTQUFTLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBQzdDLEtBQUssQ0FBQyxzQkFBc0IsR0FBRyxVQUFTLFVBQXlCO2dCQUMvRCxNQUFNLE1BQU0sR0FBRyxDQUFDLEdBQUcsT0FBTyxDQUFDLHNCQUFzQixDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUM7Z0JBQy9ELFNBQVMsQ0FBQyxJQUFJLENBQUMsaUJBQWlCLEVBQUUsR0FBRyxFQUFFO29CQUNyQyxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsZUFBZSxDQUMxQixVQUFVLEVBQUUsT0FBTyxDQUFDLGNBQWMsRUFBRSxFQUFFLE1BQU0sQ0FBQyxpQkFBaUIsRUFDOUQsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7Z0JBQ3ZCLENBQUMsQ0FBQyxDQUFDO2dCQUNILE9BQU8sTUFBTSxDQUFDO1lBQ2hCLENBQUMsQ0FBQztZQUNGLE9BQU8sS0FBSyxDQUFDO1FBQ2YsQ0FBQztLQUNGLENBQUM7SUFFRix1QkFBdUI7SUFDdkIsU0FBZ0IsZUFBZSxDQUMzQixFQUFpQixFQUFFLEVBQWtCLEVBQUUsV0FBcUIsRUFDNUQsT0FBZTtRQUNqQixTQUFTLFFBQVEsQ0FBQyxFQUFVO1lBQzFCLE9BQU8sRUFBRSxDQUFDLE9BQU8sQ0FBQyxlQUFlLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFDekMsQ0FBQztRQUNELE1BQU0sVUFBVSxHQUFrQyxFQUFFLENBQUM7UUFDckQsS0FBSyxNQUFNLENBQUMsSUFBSSxXQUFXO1lBQUUsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQztRQUU1RCxNQUFNLE1BQU0sR0FBb0IsRUFBRSxDQUFDO1FBQ25DLEtBQUssTUFBTSxJQUFJLElBQUksRUFBRSxDQUFDLFVBQVUsRUFBRTtZQUNoQyxJQUFJLElBQUksQ0FBQyxJQUFJLEtBQUssRUFBRSxDQUFDLFVBQVUsQ0FBQyxpQkFBaUI7Z0JBQzdDLElBQUksQ0FBQyxJQUFJLEtBQUssRUFBRSxDQUFDLFVBQVUsQ0FBQyxpQkFBaUIsRUFBRTtnQkFDakQsU0FBUzthQUNWO1lBQ0QsTUFBTSxFQUFFLEdBQUcsSUFBbUQsQ0FBQztZQUMvRCxNQUFNLE9BQU8sR0FBRyxFQUFFLENBQUMsZUFBZSxDQUFDO1lBQ25DLElBQUksQ0FBQyxPQUFPO2dCQUFFLFNBQVMsQ0FBRSw0QkFBNEI7WUFFckQsTUFBTSxHQUFHLEdBQUcsRUFBRSxDQUFDLG1CQUFtQixDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBQzVDLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsWUFBWSxJQUFJLEdBQUcsQ0FBQyxZQUFZLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtnQkFDNUQsU0FBUzthQUNWO1lBQ0QseURBQXlEO1lBQ3pELE1BQU0sWUFBWSxHQUFHLEdBQUcsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUMsYUFBYSxFQUFFLENBQUMsUUFBUSxDQUFDO1lBQ2xFLElBQUksVUFBVSxDQUFDLFFBQVEsQ0FBQyxZQUFZLENBQUMsQ0FBQztnQkFBRSxTQUFTO1lBQ2pELE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLE9BQU8sRUFBRSxZQUFZLENBQUMsQ0FBQztZQUM5RCxNQUFNLENBQUMsSUFBSSxDQUFDO2dCQUNWLElBQUksRUFBRSxFQUFFO2dCQUNSLEtBQUssRUFBRSxPQUFPLENBQUMsUUFBUSxFQUFFO2dCQUN6QixNQUFNLEVBQUUsT0FBTyxDQUFDLE1BQU0sRUFBRSxHQUFHLE9BQU8sQ0FBQyxRQUFRLEVBQUU7Z0JBQzdDLFdBQVcsRUFBRSw0QkFBNEIsVUFBVSxnQkFBZ0I7b0JBQy9ELGtEQUFrRDtnQkFDdEQsUUFBUSxFQUFFLEVBQUUsQ0FBQyxrQkFBa0IsQ0FBQyxLQUFLO2dCQUNyQywwQ0FBMEM7Z0JBQzFDLElBQUksRUFBRSxpQ0FBeUI7YUFDaEMsQ0FBQyxDQUFDO1NBQ0o7UUFDRCxPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDO0lBdkNELDBDQXVDQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFRoZSBCYXplbCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0ICogYXMgdHMgZnJvbSAndHlwZXNjcmlwdCc7XG5cbmltcG9ydCAqIGFzIHBlcmZUcmFjZSBmcm9tICcuL3BlcmZfdHJhY2UnO1xuaW1wb3J0ICogYXMgcGx1Z2luQXBpIGZyb20gJy4vcGx1Z2luX2FwaSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3RyaWN0RGVwc1BsdWdpbkNvbmZpZyB7XG4gIGNvbXBpbGF0aW9uVGFyZ2V0U3JjOiBzdHJpbmdbXTtcbiAgYWxsb3dlZFN0cmljdERlcHM6IHN0cmluZ1tdO1xuICByb290RGlyOiBzdHJpbmc7XG59XG5cbi8qKiBUaGUgVHlwZVNjcmlwdCBkaWFnbm9zdGljIGNvZGUgZm9yIFwiQ2Fubm90IGZpbmQgbW9kdWxlIC4uLlwiLiAqL1xuZXhwb3J0IGNvbnN0IFRTX0VSUl9DQU5OT1RfRklORF9NT0RVTEUgPSAyMzA3O1xuXG4vKipcbiAqIFRoZSBzdHJpY3RfZGVwcyBwbHVnaW4gY2hlY2tzIHRoZSBpbXBvcnRzIG9mIHRoZSBjb21waWxlZCBtb2R1bGVzLlxuICpcbiAqIEl0IGltcGxlbWVudHMgc3RyaWN0IGRlcHMsIGkuZS4gZW5mb3JjZXMgdGhhdCBlYWNoIGZpbGUgaW5cbiAqIGBjb25maWcuY29tcGlsYXRpb25UYXJnZXRTcmNgIG9ubHkgaW1wb3J0cyBmcm9tIGZpbGVzIGluXG4gKiBgY29uZmlnLmFsbG93ZWRTdHJpY3REZXBzYC5cbiAqXG4gKiBUaGlzIGlzIHVzZWQgdG8gaW1wbGVtZW50IHN0cmljdCBkZXBlbmRlbmN5IGNoZWNraW5nIC1cbiAqIHNvdXJjZSBmaWxlcyBpbiBhIGJ1aWxkIHRhcmdldCBtYXkgb25seSBpbXBvcnQgc291cmNlcyBvZiB0aGVpciBpbW1lZGlhdGVcbiAqIGRlcGVuZGVuY2llcywgYnV0IG5vdCBzb3VyY2VzIG9mIHRoZWlyIHRyYW5zaXRpdmUgZGVwZW5kZW5jaWVzLlxuICpcbiAqIHN0cmljdF9kZXBzIGFsc28gbWFrZXMgc3VyZSB0aGF0IG5vIGltcG9ydHMgZW5kcyBpbiAnLnRzJy4gVHlwZVNjcmlwdFxuICogYWxsb3dzIGltcG9ydHMgaW5jbHVkaW5nIHRoZSBmaWxlIGV4dGVuc2lvbiwgYnV0IG91ciBydW50aW1lIGxvYWRpbmcgc3VwcG9ydFxuICogZmFpbHMgd2l0aCBpdC5cbiAqXG4gKiBzdHJpY3RfZGVwcyBjdXJyZW50bHkgZG9lcyBub3QgY2hlY2sgYW1iaWVudC9nbG9iYWwgZGVmaW5pdGlvbnMuXG4gKi9cbmV4cG9ydCBjb25zdCBQTFVHSU46IHBsdWdpbkFwaS5QbHVnaW4gPSB7XG4gIHdyYXA6IChwcm9ncmFtOiB0cy5Qcm9ncmFtLCBjb25maWc6IFN0cmljdERlcHNQbHVnaW5Db25maWcpOiB0cy5Qcm9ncmFtID0+IHtcbiAgICBjb25zdCBwcm94eSA9IHBsdWdpbkFwaS5jcmVhdGVQcm94eShwcm9ncmFtKTtcbiAgICBwcm94eS5nZXRTZW1hbnRpY0RpYWdub3N0aWNzID0gZnVuY3Rpb24oc291cmNlRmlsZTogdHMuU291cmNlRmlsZSkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gWy4uLnByb2dyYW0uZ2V0U2VtYW50aWNEaWFnbm9zdGljcyhzb3VyY2VGaWxlKV07XG4gICAgICBwZXJmVHJhY2Uud3JhcCgnY2hlY2tNb2R1bGVEZXBzJywgKCkgPT4ge1xuICAgICAgICByZXN1bHQucHVzaCguLi5jaGVja01vZHVsZURlcHMoXG4gICAgICAgICAgICBzb3VyY2VGaWxlLCBwcm9ncmFtLmdldFR5cGVDaGVja2VyKCksIGNvbmZpZy5hbGxvd2VkU3RyaWN0RGVwcyxcbiAgICAgICAgICAgIGNvbmZpZy5yb290RGlyKSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICByZXR1cm4gcHJveHk7XG4gIH1cbn07XG5cbi8vIEV4cG9ydGVkIGZvciB0ZXN0aW5nXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tNb2R1bGVEZXBzKFxuICAgIHNmOiB0cy5Tb3VyY2VGaWxlLCB0YzogdHMuVHlwZUNoZWNrZXIsIGFsbG93ZWREZXBzOiBzdHJpbmdbXSxcbiAgICByb290RGlyOiBzdHJpbmcpOiB0cy5EaWFnbm9zdGljW10ge1xuICBmdW5jdGlvbiBzdHJpcEV4dChmbjogc3RyaW5nKSB7XG4gICAgcmV0dXJuIGZuLnJlcGxhY2UoLyhcXC5kKT9cXC50c3g/JC8sICcnKTtcbiAgfVxuICBjb25zdCBhbGxvd2VkTWFwOiB7W2ZpbGVOYW1lOiBzdHJpbmddOiBib29sZWFufSA9IHt9O1xuICBmb3IgKGNvbnN0IGQgb2YgYWxsb3dlZERlcHMpIGFsbG93ZWRNYXBbc3RyaXBFeHQoZCldID0gdHJ1ZTtcblxuICBjb25zdCByZXN1bHQ6IHRzLkRpYWdub3N0aWNbXSA9IFtdO1xuICBmb3IgKGNvbnN0IHN0bXQgb2Ygc2Yuc3RhdGVtZW50cykge1xuICAgIGlmIChzdG10LmtpbmQgIT09IHRzLlN5bnRheEtpbmQuSW1wb3J0RGVjbGFyYXRpb24gJiZcbiAgICAgICAgc3RtdC5raW5kICE9PSB0cy5TeW50YXhLaW5kLkV4cG9ydERlY2xhcmF0aW9uKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgaWQgPSBzdG10IGFzIHRzLkltcG9ydERlY2xhcmF0aW9uIHwgdHMuRXhwb3J0RGVjbGFyYXRpb247XG4gICAgY29uc3QgbW9kU3BlYyA9IGlkLm1vZHVsZVNwZWNpZmllcjtcbiAgICBpZiAoIW1vZFNwZWMpIGNvbnRpbnVlOyAgLy8gRS5nLiBhIGJhcmUgXCJleHBvcnQge3h9O1wiXG5cbiAgICBjb25zdCBzeW0gPSB0Yy5nZXRTeW1ib2xBdExvY2F0aW9uKG1vZFNwZWMpO1xuICAgIGlmICghc3ltIHx8ICFzeW0uZGVjbGFyYXRpb25zIHx8IHN5bS5kZWNsYXJhdGlvbnMubGVuZ3RoIDwgMSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIC8vIE1vZHVsZSBpbXBvcnRzIGNhbiBvbmx5IGhhdmUgb25lIGRlY2xhcmF0aW9uIGxvY2F0aW9uLlxuICAgIGNvbnN0IGRlY2xGaWxlTmFtZSA9IHN5bS5kZWNsYXJhdGlvbnNbMF0uZ2V0U291cmNlRmlsZSgpLmZpbGVOYW1lO1xuICAgIGlmIChhbGxvd2VkTWFwW3N0cmlwRXh0KGRlY2xGaWxlTmFtZSldKSBjb250aW51ZTtcbiAgICBjb25zdCBpbXBvcnROYW1lID0gcGF0aC5wb3NpeC5yZWxhdGl2ZShyb290RGlyLCBkZWNsRmlsZU5hbWUpO1xuICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgIGZpbGU6IHNmLFxuICAgICAgc3RhcnQ6IG1vZFNwZWMuZ2V0U3RhcnQoKSxcbiAgICAgIGxlbmd0aDogbW9kU3BlYy5nZXRFbmQoKSAtIG1vZFNwZWMuZ2V0U3RhcnQoKSxcbiAgICAgIG1lc3NhZ2VUZXh0OiBgdHJhbnNpdGl2ZSBkZXBlbmRlbmN5IG9uICR7aW1wb3J0TmFtZX0gbm90IGFsbG93ZWQuIGAgK1xuICAgICAgICAgIGBQbGVhc2UgYWRkIHRoZSBCVUlMRCB0YXJnZXQgdG8geW91ciBydWxlJ3MgZGVwcy5gLFxuICAgICAgY2F0ZWdvcnk6IHRzLkRpYWdub3N0aWNDYXRlZ29yeS5FcnJvcixcbiAgICAgIC8vIHNlbWFudGljcyBhcmUgY2xvc2UgZW5vdWdoLCBuZWVkcyB0YXplLlxuICAgICAgY29kZTogVFNfRVJSX0NBTk5PVF9GSU5EX01PRFVMRSxcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuIl19