import { Compiler } from "./compiler";
import { Expect } from "./expect";
import * as tsutils from "tsutils";
var Snippet = (function () {
    function Snippet(_files, _compiler) {
        this._files = _files;
        this._compiler = _compiler;
        this.assertFail = function (message) {
            throw new Error(message);
        };
        this.assertPass = function () { };
        this._program = _compiler.compile(_files);
    }
    Snippet.prototype.fail = function (fileName, expectedMessage) {
        var diagnostics = this._getDiagnostics(fileName);
        var messages = diagnostics.map(this._compiler.formatDiagnostic);
        var matched = messages.some(function (message) {
            return expectedMessage ? expectedMessage.test(message) : true;
        });
        if (!matched) {
            this.assertFail(expectedMessage
                ? "Expected an error matching " + expectedMessage
                : "Expected an error");
        }
        else {
            this.assertPass();
        }
    };
    Snippet.prototype.expect = function (fileName) {
        return new Expect(this.fail.bind(this, fileName), this.infer.bind(this, fileName), this.succeed.bind(this, fileName));
    };
    Snippet.prototype.infer = function (fileName, variableName, expectedType) {
        var sourceFile = this._program.getSourceFile(fileName);
        var variables = getVariables(this._program, sourceFile);
        var actualType = variables[variableName];
        if (!actualType) {
            this.assertFail("Variable '" + variableName + "' not found");
        }
        else if (!areEquivalentTypeStrings(expectedType, actualType)) {
            this.assertFail("Expected '" + variableName + ": " + actualType + "' to be '" + expectedType + "'");
        }
        else {
            this.assertPass();
        }
    };
    Snippet.prototype.succeed = function (fileName) {
        var diagnostics = this._getDiagnostics(fileName);
        if (diagnostics.length) {
            var diagnostic = diagnostics[0];
            this.assertFail(this._compiler.formatDiagnostic(diagnostic));
        }
        else {
            this.assertPass();
        }
    };
    Snippet.prototype._getDiagnostics = function (fileName) {
        return this._program
            .getSemanticDiagnostics()
            .concat(this._compiler.getDiagnostics(fileName));
    };
    return Snippet;
}());
export { Snippet };
export function areEquivalentTypeStrings(a, b) {
    var spaces = /\s/g;
    return a.replace(spaces, "") === b.replace(spaces, "");
}
export function getVariables(program, sourceFile) {
    var typeChecker = program.getTypeChecker();
    var variables = {};
    var visitNode = function (node) {
        if (tsutils.isVariableStatement(node)) {
            tsutils.forEachDeclaredVariable(node.declarationList, function (node) {
                variables[node.name.getText()] = typeChecker.typeToString(typeChecker.getTypeAtLocation(node));
            });
        }
        else {
            node.forEachChild(visitNode);
        }
    };
    sourceFile.forEachChild(visitNode);
    return variables;
}
export function snippet(files, compiler) {
    return new Snippet(files, compiler || new Compiler());
}
